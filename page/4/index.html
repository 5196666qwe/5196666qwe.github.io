
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ChenXing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ChenXing">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="ChenXing">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ChenXing">
  
    <link rel="alternative" href="/atom.xml" title="ChenXing" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ChenXing</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-Python中super函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/22/Python中super函数/" class="article-date">
  <time datetime="2016-11-22T05:59:55.000Z" itemprop="datePublished">2016-11-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/22/Python中super函数/">Python中super</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<p>啃Python时候，发现super的几个问题，开始我以为这货和java中的super有点类似，毕竟效果看起来差不多。</p>
<p>然后又发现怎么这货还有参数的，而且参数还是那么奇葩，这么反人类啊。</p>
<p>之后查了点资料，才知道我是逗逼。。</p>
<h2 id="为什么super一般是两个参数的"><a href="#为什么super一般是两个参数的" class="headerlink" title="为什么super一般是两个参数的?"></a>为什么super一般是两个参数的?</h2><p><strong>请无视出现的父类名词，只是便于说明。</strong></p>
<p>我们最常见的，可以说几乎唯一能见到的使用super的形式是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span><span class="params">(BaseClass)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></div><div class="line">		super(SubClass, self).method()</div><div class="line">		<span class="comment">#do some thing here...</span></div></pre></td></tr></table></figure>
<p>其中，最常见的method()是<code>__init__()</code></p>
<p>当我第一次见到这个super()的时候，我想说，这是啥啊？为什么Python的super看起来这么奇怪呢？</p>
<p>super直接指向父类的实例不就得了么？<strong>为什么非得搞两个参数？</strong></p>
<p>而且第一个参数还是自己的类名，而不是父类的类名！</p>
<p>既然是自己的类名你还费劲写一遍干嘛，干脆省略不得了？</p>
<p>第二个参数为啥是self？既然是self你省略不得了？</p>
<p>还有，super()返回的是个啥玩意啊，为什么可以.method() ? 难道他返回了一个`BaseClass的instance么？</p>
<p>今天就来解答这一连串的问题。</p>
<p>首先是不能指向，因为子类实例里面根本就没有一个父类实例，这跟java是不同的。</p>
<p>其次就算有，子类实例里面有个super的指针，指向父类的实例，因为多继承的关系，会存在问题。你子类不知道调用一个方法时（子类不重写父类方法时），不知道是调用哪一个父类的方法。假设说你任意调用了其中一个父类的方法，那么就体现不出来其他父类的特点了。如果都调用的话，就更糟糕了。你要是其中一个父类没有这个方法，不就over了。。</p>
<p>那么我们自然想到，给super搞一个参数不得了，指出super的是哪个父类。</p>
<p>先不说这种写法多么的丑陋，重复了那么多无意义的、类似的行，单说这种方法根本就行不通。</p>
<p>比如A类继承了两个类B，C，两个类又共同继承了另一个类D。（假设BCA都重写了D方法）那么，你调用A的方法时候，D类的方法会执行两遍。。这是多傻逼的一种行为。</p>
<p>所以，python的super()用了两个参数。</p>
<h2 id="Super究竟是什么？"><a href="#Super究竟是什么？" class="headerlink" title="Super究竟是什么？"></a>Super究竟是什么？</h2><p>要谈论 <code>super</code>，首先我们应该无视 “super” 这个名字带给我们的干扰。</p>
<p><strong>不要一说到 super 就想到父类！super 指的是 MRO 中的下一个类！</strong><br><strong>不要一说到 super 就想到父类！super 指的是 MRO 中的下一个类！</strong><br><strong>不要一说到 super 就想到父类！super 指的是 MRO 中的下一个类！</strong></p>
<p>看这篇文章：<a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" target="_blank" rel="external">Python’s super() considered super!</a> 这是 Raymond Hettinger 写的一篇文章，也是全世界公认的对 <code>super</code> 讲解最透彻的一篇文章，凡是讨论 super 都一定会提到它（当然还有一篇 Python’s Super Considered Harmful）。</p>
<p>如果不想看长篇大论就去看<a href="http://stackoverflow.com/questions/15896265/python-super-inheritance-and-arguments-needed/15896594#15896594" target="_blank" rel="external">这个答案</a>，<code>super</code> 其实干的是这件事：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(cls, inst)</span>:</span></div><div class="line">    mro = inst.__class__.mro()</div><div class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>两个参数 cls 和 inst 分别做了两件事： </p>
<ol>
<li><p><strong>inst 负责生成 MRO 的 list</strong> </p>
</li>
<li><p><strong>通过 cls 定位当前 MRO 中的 index, 并返回 mro[index + 1]</strong> </p>
<p>这两件事才是 super 的实质，一定要记住！ </p>
<p>MRO 全称 Method Resolution Order，它代表了类继承的顺序。后面详细说。</p>
</li>
</ol>
<p>举个例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"this is Root"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Root)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"enter B"</span>)</div><div class="line">        <span class="comment"># print(self)  # this will print &lt;__main__.D object at 0x...&gt;</span></div><div class="line">        super(B, self).__init__()</div><div class="line">        print(<span class="string">"leave B"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(Root)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"enter C"</span>)</div><div class="line">        super(C, self).__init__()</div><div class="line">        print(<span class="string">"leave C"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">d = D()</div><div class="line">print(d.__class__.__mro__)</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enter B</div><div class="line">enter C</div><div class="line">this is Root</div><div class="line">leave C</div><div class="line">leave B</div><div class="line">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;type 'object'&gt;)</div></pre></td></tr></table></figure>
<p>知道了 <code>super</code> 和父类其实没有实质关联之后，我们就不难理解为什么 enter B 下一句是 enter C 而不是 this is Root（如果认为 super 代表“调用父类的方法”，会想当然的认为下一句应该是this is Root）。流程如下，在 B 的 <code>__init__</code> 函数中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">super(B, self).__init__()</div></pre></td></tr></table></figure>
<p>首先，我们获取 <code>self.__class__.__mro__</code>，注意这里的 self 是D的instance 而不是 B 的[你可以看成是d.init()]</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;type 'object'&gt;)</div></pre></td></tr></table></figure>
<p>然后，通过 B 来定位 MRO 中的 index，并找到下一个。显然 B 的下一个是 C。于是，我们调用 C 的 <code>__init__</code>，打出 enter C。</p>
<p>顺便说一句为什么 B 的 <code>__init__</code> 会被调用：因为 D 没有定义 <code>__init__</code>，所以会在 MRO 中找下一个类，去查看它有没有定义 <code>__init__</code>，也就是去调用 B 的 <code>__init__</code>。</p>
<p>其实这一切逻辑还是很清晰的，关键是理解 <code>super</code> 到底做了什么。</p>
<p>于是，MRO 中类的顺序到底是怎么排的呢？Python’s super() considered super!中已经有很好的解释，我翻译一下：<br><strong>在 MRO 中，基类永远出现在派生类后面，如果有多个基类，基类的相对顺序保持不变。</strong> </p>
<p><strong>本人技术有限，且技术更新很快，如果文中存在错误或者不足，欢迎大家指正，相互交流。</strong></p>
<p>参考：</p>
<p><a href="http://zsl-oo7.blog.163.com/blog/static/35329703201502901052503/" target="_blank" rel="external"><strong>Python 的 super，一次性整明白</strong></a></p>
<p><a href="https://laike9m.com/blog/li-jie-python-super,70/" target="_blank" rel="external"><strong>理解 Python super</strong></a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/11/22/Python中super函数/" data-id="cj8lswfmo000z5svba8hhneih" class="article-share-link" data-share="baidu" data-title="Python中super">Share</a>
      

      
        <a href="http://yoursite.com/2016/11/22/Python中super函数/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-(转载)Nodejs源码解析之events" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/20/(转载)Nodejs源码解析之events/" class="article-date">
  <time datetime="2016-11-20T12:53:53.000Z" itemprop="datePublished">2016-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Node/">Node</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/20/(转载)Nodejs源码解析之events/">(转载)Nodejs源码解析之events</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在分析events源码之前，我们来看看js设计模式中的发布 — 订阅模式。</p>
<h2 id="发布—订阅模式"><a href="#发布—订阅模式" class="headerlink" title="发布—订阅模式"></a>发布—订阅模式</h2><p>发布 — 订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状<br>态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript开发中，我们一般用事件模型<br>来替代传统的发布 — 订阅模式。</p>
<p>如何一步步实现发布 — 订阅模式？</p>
<ol>
<li>首先要指定好谁充当发布者</li>
<li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者</li>
<li>最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函<br>数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> event = &#123;</div><div class="line">	<span class="attr">events</span>:&#123;&#125;, <span class="comment">//缓存列表</span></div><div class="line">	on:<span class="function"><span class="keyword">function</span> (<span class="params">key,fn</span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> ( !<span class="keyword">this</span>.events[ key ])&#123; <span class="comment">//如果还没有订阅过此类消息，给该类消息创建一个缓存列表</span></div><div class="line">			<span class="keyword">this</span>.events[ key ]= [];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.events[ key ].push(fn); <span class="comment">// 订阅的消息添加进消息缓存列表</span></div><div class="line">	&#125;,</div><div class="line">	<span class="attr">emit</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 发布消息</span></div><div class="line">		<span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>), <span class="comment">// 取出消息类型</span></div><div class="line">			fns = <span class="keyword">this</span>.events[ key ];  <span class="comment">// 取出该消息对应的回调函数集合</span></div><div class="line">		<span class="keyword">if</span> ( !fns || fns.length === <span class="number">0</span> )&#123; <span class="comment">// 如果没有订阅该消息，则返回</span></div><div class="line">			<span class="keyword">return</span> ;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span> ( <span class="keyword">var</span> i= <span class="number">0</span>,fn; fn=fns[i++];)&#123; <span class="comment">// arguments 是发布消息时附送的参数</span></div><div class="line">			fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="attr">remove</span>: <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> fns = <span class="keyword">this</span>.events[ key ];</div><div class="line">		<span class="keyword">if</span> ( !key || !fns)&#123;  <span class="comment">// 如果 key 对应的消息没有被人订阅，则直接返回</span></div><div class="line">			<span class="keyword">return</span>; </div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> ( !fn )&#123;  <span class="comment">// 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span></div><div class="line">			fns &amp;&amp; (fns.length=<span class="number">0</span>);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">var</span> l = fns.length<span class="number">-1</span>; l&gt;=<span class="number">0</span>;l--)&#123;  <span class="comment">// 反向遍历订阅的回调函数列表</span></div><div class="line">				<span class="keyword">var</span> _fn = fns[l];</div><div class="line">				<span class="keyword">if</span> ( _fn === fn )&#123;</div><div class="line">					fns.splice(l,<span class="number">1</span>); <span class="comment">// 删除订阅者的回调函数</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	<span class="attr">once</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> key,fn </span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> fired = <span class="literal">false</span>;   <span class="comment">//防止二次once。</span></div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">this</span>.remove(key,fn);</div><div class="line">			<span class="keyword">if</span> ( !fired )&#123;</div><div class="line">				fired = <span class="literal">true</span>;</div><div class="line">				fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;	</div><div class="line">		<span class="keyword">this</span>.on( key, g );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">event.on(<span class="string">"tell"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;  <span class="comment">//订阅信息</span></div><div class="line">	<span class="built_in">console</span>.log(key);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">event.emit(<span class="string">"tell"</span>,<span class="number">1</span>);  <span class="comment">//发布信息</span></div><div class="line">event.remove(<span class="string">"tell"</span>);  <span class="comment">//移除信息</span></div><div class="line">event.emit(<span class="string">"tell"</span>,<span class="number">1</span>);</div></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>Nodejs中的events模块是很常见的模块，其实现了事件注册，通知等功能，是观察者模式的实现。其使用很简单，实例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 导入events模块</span></div><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="comment">// 创建EventEmitter对象</span></div><div class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</div><div class="line"></div><div class="line"><span class="comment">//回调函数1</span></div><div class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'listener1 executed.'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数2</span></div><div class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'listener2 executed.'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 注册事件的回调函数， 相当于增加观察者</span></div><div class="line">eventEmitter.addListener(<span class="string">'connection'</span>, listener1);</div><div class="line"></div><div class="line"><span class="comment">// 再次注册同样事件的回调函数， 相当于增加观察者</span></div><div class="line">eventEmitter.on(<span class="string">'connection'</span>, listener2);</div><div class="line"></div><div class="line"><span class="comment">// 触发事件，这个时候，会有函数 listener1 和listener2同时被调用</span></div><div class="line">eventEmitter.emit(<span class="string">'connection'</span>);</div></pre></td></tr></table></figure>
<p>上述代码使用是相当简单的，这个是如何实现的的呢？ 其实这个是一般观察者的设计模式的实现逻辑是类似的，都是有一个缓存列表，存储监听事件和回调函数的对应关系，当监听事件发生时，调用回调函数，这个也不例外。不多说，来看源代码吧。</p>
<p><strong>初始化</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//这个就是用于调用Init函数,</span></div><div class="line">  EventEmitter.init.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 导出函数，这个就是一个events模块的总体导出函数</span></div><div class="line"><span class="comment">// 在上述的用法中，我们都是需要创建一个EventEmitter对象的</span></div><div class="line"><span class="built_in">module</span>.exports = EventEmitter;</div><div class="line"></div><div class="line"><span class="comment">// 用于兼容node 0.10.x</span></div><div class="line">EventEmitter.EventEmitter = EventEmitter;</div><div class="line"><span class="comment">// 是否使用domain，默认用法是不使用。Domain其实是EventEmitter子类，</span></div><div class="line"><span class="comment">// 一个单独的模块，这里不进一步分析，有兴趣可以看domain.js</span></div><div class="line">EventEmitter.usingDomains = <span class="literal">false</span>;</div><div class="line"><span class="comment">// 同上，用于domain模块</span></div><div class="line">EventEmitter.prototype.domain = <span class="literal">undefined</span>;</div><div class="line"><span class="comment">// 这个就是用于存储事件和回调的类map对象</span></div><div class="line">EventEmitter.prototype._events = <span class="literal">undefined</span>;</div><div class="line"><span class="comment">// </span></div><div class="line">EventEmitter.prototype._maxListeners = <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="comment">// By default EventEmitters will print a warning if more than 10 listeners // are added to it. This is a useful default which helps finding memory leaks.</span></div><div class="line"><span class="comment">// 默认的最大的观察者的个数，默认为10， 如果超过，会有警告信息，以避免内存泄漏</span></div><div class="line">EventEmitter.defaultMaxListeners = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// 初始化，构造函数必须调用的部分</span></div><div class="line">EventEmitter.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 下面是对domain的处理，不考虑</span></div><div class="line">  <span class="keyword">this</span>.domain = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">if</span> (EventEmitter.usingDomains) &#123;</div><div class="line">    <span class="comment">// if there is an active domain, then attach to it.</span></div><div class="line">    domain = domain || <span class="built_in">require</span>(<span class="string">'domain'</span>);</div><div class="line">    <span class="keyword">if</span> (domain.active &amp;&amp; !(<span class="keyword">this</span> <span class="keyword">instanceof</span> domain.Domain)) &#123;</div><div class="line">      <span class="keyword">this</span>.domain = domain.active;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">   <span class="comment">// 创建了一个_events 的空对象，相当于创建了一个map</span></div><div class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>._events || <span class="keyword">this</span>._events === <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>)._events)</div><div class="line">    <span class="keyword">this</span>._events = &#123;&#125;;</div><div class="line">  <span class="comment">// 用于保存当前最大监听数目，后面会用到</span></div><div class="line">  <span class="keyword">this</span>._maxListeners = <span class="keyword">this</span>._maxListeners || <span class="literal">undefined</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过上述的源码分析，可以得出，当我们创建<code>EventEmitter对象</code>时候，其实就是生成了一个<code>_events的空对象</code>，做一些基本的检查。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 导入events模块</span></div><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="comment">// 创建EventEmitter对象</span></div><div class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</div><div class="line"><span class="comment">//也可以直接 new events();</span></div></pre></td></tr></table></figure>
<p><strong>增/删 监听</strong></p>
<p>首先来查看一下增加监听相关的源代码，这里有三个函数：</p>
<ul>
<li>addListener: 增加事件监听。</li>
<li>on： addListener的别名，实际上是一样的。</li>
<li>once： 增加事件监听，不同的是，事件被fire一次后，会掉函数不再被执行。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> <span class="title">addListener</span>(<span class="params">type, listener</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> m;</div><div class="line">   <span class="comment">// 首先查看的是否listener为一个函数，确保是可以被执行的会掉函数</span></div><div class="line">  <span class="keyword">if</span> (!util.isFunction(listener))</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'listener must be a function'</span>);</div><div class="line"></div><div class="line">  <span class="comment">//确保_events对象已经被创建</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events)</div><div class="line">    <span class="keyword">this</span>._events = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="comment">// To avoid recursion in the case that type === "newListener"! Before</span></div><div class="line">  <span class="comment">// adding it to the listeners, first emit "newListener".</span></div><div class="line">  <span class="comment">// 从注释上，这个是防止递归调用的，这里只有定义了newListener后，才会发送事件</span></div><div class="line">  <span class="comment">// newListener，从本函数的代码，可以看出，newListener没有被定义，可以忽视</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._events.newListener)</div><div class="line">    <span class="keyword">this</span>.emit(<span class="string">'newListener'</span>, type,</div><div class="line">              util.isFunction(listener.listener) ?</div><div class="line">              listener.listener : listener);</div><div class="line">  <span class="comment">// 查看该type（事件）是否存在，</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events[type])</div><div class="line">    <span class="comment">// Optimize the case of one listener. Don't need the extra array object.</span></div><div class="line">    <span class="comment">// 如果不存在，直接存入就可以</span></div><div class="line">    <span class="keyword">this</span>._events[type] = listener;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (util.isObject(<span class="keyword">this</span>._events[type]))</div><div class="line">    <span class="comment">// If we've already got an array, just append.</span></div><div class="line">     <span class="comment">// 如果存在，并且是array，直接push</span></div><div class="line">    <span class="keyword">this</span>._events[type].push(listener);</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="comment">// Adding the second element, need to change to array.</span></div><div class="line">    <span class="comment">// 如果不是array，生成一个新的array</span></div><div class="line">    <span class="keyword">this</span>._events[type] = [<span class="keyword">this</span>._events[type], listener];</div><div class="line"></div><div class="line">  <span class="comment">// Check for listener leak</span></div><div class="line">  <span class="comment">// 下面的代码就是查看是否监听者超过了最大的数目，这个是关于默认的数目的</span></div><div class="line">  <span class="keyword">if</span> (util.isObject(<span class="keyword">this</span>._events[type]) &amp;&amp; !<span class="keyword">this</span>._events[type].warned) &#123;</div><div class="line">    <span class="keyword">var</span> m;</div><div class="line">    <span class="keyword">if</span> (!util.isUndefined(<span class="keyword">this</span>._maxListeners)) &#123;</div><div class="line">      m = <span class="keyword">this</span>._maxListeners;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      m = EventEmitter.defaultMaxListeners;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">//如果数目过大，直接给出console.error</span></div><div class="line">    <span class="keyword">if</span> (m &amp;&amp; m &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>._events[type].length &gt; m) &#123;</div><div class="line">      <span class="keyword">this</span>._events[type].warned = <span class="literal">true</span>;</div><div class="line">      <span class="built_in">console</span>.error(<span class="string">'(node) warning: possible EventEmitter memory '</span> +</div><div class="line">                    <span class="string">'leak detected. %d %s listeners added. '</span> +</div><div class="line">                    <span class="string">'Use emitter.setMaxListeners() to increase limit.'</span>,</div><div class="line">                    <span class="keyword">this</span>._events[type].length, type);</div><div class="line">      <span class="built_in">console</span>.trace();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 这里就是说on 和addListener是相互一样的，别名。</span></div><div class="line">EventEmitter.prototype.on = EventEmitter.prototype.addListener;</div><div class="line"><span class="comment">// 查看once，事件触发一次回调函数，就删除，相当于调用了removeListener</span></div><div class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">type, listener</span>) </span>&#123;</div><div class="line">  <span class="comment">// 依然一样是确保参数为函数，可以回调</span></div><div class="line">  <span class="keyword">if</span> (!util.isFunction(listener))</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'listener must be a function'</span>);</div><div class="line">  <span class="comment">// 回调函数是否被fire了 </span></div><div class="line">  <span class="keyword">var</span> fired = <span class="literal">false</span>;</div><div class="line">  <span class="comment">// 帮助函数</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 删除回调函数，请注意，一旦被fired掉，就删除</span></div><div class="line">    <span class="keyword">this</span>.removeListener(type, g);</div><div class="line">    <span class="comment">// 检查是否被fired过了，我想，这个可能是防止重复增加的case，也就是多次调用了once的  情况</span></div><div class="line">    <span class="keyword">if</span> (!fired) &#123;</div><div class="line">      fired = <span class="literal">true</span>;</div><div class="line">      <span class="comment">// 执行回调函数</span></div><div class="line">      listener.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 增加一个listener属性为回调函数</span></div><div class="line">  g.listener = listener;</div><div class="line">  <span class="comment">// 增加具体的回调函数，该回调函数变成了帮助函数g，而不是listener</span></div><div class="line">  <span class="keyword">this</span>.on(type, g);</div><div class="line">  <span class="comment">// 返回整个对象</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下面介绍一下删除回调相关的函数。</p>
<ul>
<li>removeListener - 删除具体的事件回调</li>
<li>removeAllListeners - 删除具体时间相关的所有的回调</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">EventEmitter.prototype.removeListener =</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeListener</span>(<span class="params">type, listener</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> list, position, length, i;</div><div class="line"></div><div class="line">  <span class="comment">//依然是检查listener是否为函数</span></div><div class="line">  <span class="keyword">if</span> (!util.isFunction(listener))</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'listener must be a function'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 确保_events是否为空，以及事件存在在对象中</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events || !<span class="keyword">this</span>._events[type])</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  <span class="comment">// 等到回调函数的value</span></div><div class="line">  list = <span class="keyword">this</span>._events[type];</div><div class="line">  length = list.length;</div><div class="line">  position = <span class="number">-1</span>;</div><div class="line">  <span class="comment">// 如果当前的value和要删除的回调是相等的，包含once的内容</span></div><div class="line">  <span class="keyword">if</span> (list === listener ||</div><div class="line">      (util.isFunction(list.listener) &amp;&amp; list.listener === listener)) &#123;</div><div class="line">    <span class="comment">// 直接删除</span></div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._events[type];</div><div class="line">    <span class="comment">// 发送事件</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._events.removeListener)</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, listener);</div><div class="line">  &#125; <span class="comment">// 如果是队列，直接出来</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (util.isObject(list)) &#123;</div><div class="line">    <span class="keyword">for</span> (i = length; i-- &gt; <span class="number">0</span>;) &#123;</div><div class="line">      <span class="keyword">if</span> (list[i] === listener ||</div><div class="line">          (list[i].listener &amp;&amp; list[i].listener === listener)) &#123;</div><div class="line">        position = i;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">// 如果查找不到，直接返回</span></div><div class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">     <span class="comment">// 如果长度为1，说明可以删除</span></div><div class="line">    <span class="keyword">if</span> (list.length === <span class="number">1</span>) &#123;</div><div class="line">      list.length = <span class="number">0</span>;</div><div class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>._events[type];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// 直接在数组中删除该回调</span></div><div class="line">      list.splice(position, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">     <span class="comment">// fire removeListener事件</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._events.removeListener)</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, listener);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 删除与单一事件相关的所有回调函数</span></div><div class="line">EventEmitter.prototype.removeAllListeners =</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeAllListeners</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> key, listeners;</div><div class="line"> <span class="comment">// 确保_events不为空</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  <span class="comment">// not listening for removeListener, no need to emit</span></div><div class="line">  <span class="comment">// 查看当前是否有removeListener的监听者，从本模块看，没有赋值，所以一般情况下，都是</span></div><div class="line">  <span class="comment">// 直接删除回调然后返回</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events.removeListener) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>)</div><div class="line">      <span class="keyword">this</span>._events = &#123;&#125;;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._events[type])</div><div class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>._events[type];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// emit removeListener for all listeners on all events</span></div><div class="line">  <span class="comment">// 处理没有参数的情况，在没有参数的情况下，就是删除所有事件的回调</span></div><div class="line">  <span class="comment">// 相当于清空。 </span></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> <span class="keyword">this</span>._events) &#123;</div><div class="line">      <span class="comment">// 注意有特殊情况是，不删除removeListener的回调</span></div><div class="line">      <span class="keyword">if</span> (key === <span class="string">'removeListener'</span>) <span class="keyword">continue</span>;</div><div class="line">      <span class="keyword">this</span>.removeAllListeners(key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.removeAllListeners(<span class="string">'removeListener'</span>);</div><div class="line">    <span class="keyword">this</span>._events = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 处理有具体参数的情况， 找到具体回调函数</span></div><div class="line">  listeners = <span class="keyword">this</span>._events[type];</div><div class="line"></div><div class="line">  <span class="comment">// 如果回调是单个函数，直接删除就好</span></div><div class="line">  <span class="keyword">if</span> (util.isFunction(listeners)) &#123;</div><div class="line">    <span class="keyword">this</span>.removeListener(type, listeners);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(listeners)) &#123;</div><div class="line">    <span class="comment">// LIFO order</span></div><div class="line">    <span class="comment">// 处理回调函数是一个数组的情况，从后往前一个一个删除。</span></div><div class="line">    <span class="keyword">while</span> (listeners.length)</div><div class="line">      <span class="keyword">this</span>.removeListener(type, listeners[listeners.length - <span class="number">1</span>]);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 清空事件对于的回调函数对象</span></div><div class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>._events[type];</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>事件触发</strong></p>
<p>事件触发是由<code>emit函数</code>来实现的，具体的含义就是发送一个事件，这个会同步的调用回调函数。 具体的源代码解析如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> er, handler, len, args, i, listeners;</div><div class="line">  <span class="comment">// 还是检查当前存储的events队列是否为空</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events)</div><div class="line">    <span class="keyword">this</span>._events = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="comment">// If there is no 'error' event listener then throw.</span></div><div class="line">  <span class="comment">// 这里需要对error进行特殊处理，如果没有error事件的监听者，直接会抛出error的错误，</span></div><div class="line">  <span class="comment">// 所有对error的时间的处理要特别注意。</span></div><div class="line">  <span class="comment">// 也就是所emit（‘error’）有抛出异常的功能，这个是文档中没有的</span></div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'error'</span> &amp;&amp; !<span class="keyword">this</span>._events.error) &#123;</div><div class="line">    er = <span class="built_in">arguments</span>[<span class="number">1</span>];</div><div class="line">    <span class="comment">// 这个是具体domain的处理</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain) &#123;</div><div class="line">      <span class="keyword">if</span> (!er)</div><div class="line">        er = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Uncaught, unspecified "error" event.'</span>);</div><div class="line">      er.domainEmitter = <span class="keyword">this</span>;</div><div class="line">      er.domain = <span class="keyword">this</span>.domain;</div><div class="line">      er.domainThrown = <span class="literal">false</span>;</div><div class="line">      <span class="keyword">this</span>.domain.emit(<span class="string">'error'</span>, er);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (er <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</div><div class="line">      <span class="comment">// 直接抛出异常，如果emit一个参数Error的实例</span></div><div class="line">      <span class="keyword">throw</span> er; <span class="comment">// Unhandled 'error' event</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">//抛出生成的异常</span></div><div class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Uncaught, unspecified "error" event.'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 找到对应事件的回调函数</span></div><div class="line">  handler = <span class="keyword">this</span>._events[type];</div><div class="line"> <span class="comment">// 如果回调函数没有定义，说明不存在，直接返回false</span></div><div class="line">  <span class="keyword">if</span> (util.isUndefined(handler))</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="comment">// 如果是domain的使用，直接进入domain内处理</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.domain &amp;&amp; <span class="keyword">this</span> !== process)</div><div class="line">    <span class="keyword">this</span>.domain.enter();</div><div class="line">  <span class="comment">//处理是单个的函数的情况。</span></div><div class="line">  <span class="keyword">if</span> (util.isFunction(handler)) &#123;</div><div class="line">    <span class="comment">// 检查参数的情况，注意，至少有事件这一个argument。所以先处理1，2，3</span></div><div class="line">    <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</div><div class="line">      <span class="comment">// fast cases</span></div><div class="line">      <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        <span class="comment">// 当回调函数没有参数时候</span></div><div class="line">        handler.call(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        <span class="comment">// 当回调函数有一个参数时候</span></div><div class="line">        handler.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">        <span class="comment">// 当回调函数有二个参数时候</span></div><div class="line">        handler.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>]);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="comment">// slower</span></div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="comment">// 当回调函数三个或者以上参数时候，就会做一个copy，然后再调用</span></div><div class="line">        <span class="comment">// 所以，这里我们可以特别注意的地方是，为了效率考虑，回调函数最好不要用3个或者3个以上的函数参数</span></div><div class="line">        len = <span class="built_in">arguments</span>.length;</div><div class="line">        args = <span class="keyword">new</span> <span class="built_in">Array</span>(len - <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</div><div class="line">          args[i - <span class="number">1</span>] = <span class="built_in">arguments</span>[i];</div><div class="line">        handler.apply(<span class="keyword">this</span>, args);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="comment">// 这里处理回调函数为一个数组的情况</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (util.isObject(handler)) &#123;</div><div class="line">    <span class="comment">// 这里直接生成一个参数的拷贝</span></div><div class="line">    len = <span class="built_in">arguments</span>.length;</div><div class="line">    args = <span class="keyword">new</span> <span class="built_in">Array</span>(len - <span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</div><div class="line">      args[i - <span class="number">1</span>] = <span class="built_in">arguments</span>[i];</div><div class="line">    <span class="comment">// 生成一个回调函数的新队列</span></div><div class="line">    listeners = handler.slice();</div><div class="line">    len = listeners.length;</div><div class="line">    <span class="comment">// 逐个调用回调函数</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">      listeners[i].apply(<span class="keyword">this</span>, args);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 处理domain 的情况，直接退出</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.domain &amp;&amp; <span class="keyword">this</span> !== process)</div><div class="line">    <span class="keyword">this</span>.domain.exit();</div><div class="line">  <span class="comment">//返回true，有回调函数处理的情况 </span></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/nodejs/node/blob/master/lib/events.js" target="_blank" rel="external">events源码</a></p>
<p><a href="http://blog.csdn.net/leoleocs/article/details/50162065" target="_blank" rel="external">Nodejs源码解析之events</a></p>
<p><a href="javascript设计模式与开发实践">发布-订阅模式</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/11/20/(转载)Nodejs源码解析之events/" data-id="cj8lswfm000045svbbe0u19jr" class="article-share-link" data-share="baidu" data-title="(转载)Nodejs源码解析之events">Share</a>
      

      
        <a href="http://yoursite.com/2016/11/20/(转载)Nodejs源码解析之events/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node/">Node</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS中常用方法的模拟" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/20/JS中常用方法的模拟/" class="article-date">
  <time datetime="2016-11-20T05:59:55.000Z" itemprop="datePublished">2016-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/20/JS中常用方法的模拟/">JS中常用方法的模拟</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="new的模拟"><a href="#new的模拟" class="headerlink" title="new的模拟"></a>new的模拟</h2><p>new对象的过程</p>
<ol>
<li>创建一个空的<code>Object</code>对象 <code>var obj = new Object();</code></li>
<li>将构造函数<code>Person</code>中<code>this</code>指向刚创建的<code>obj对象</code>(this不懂，请看this那一章)</li>
<li>将创建的<code>obj</code>的<code>__proto__</code>指向构造函数的<code>prototype</code>，这一步是建立对象和原型直接的对应关系(注意: <code>__proto__</code>不是标准，chrome和firefox自己实现的，ie不支持)</li>
<li>执行构造函数中的代码</li>
</ol>
<p>明白了原理，我们就可以自己写一个New函数了。</p>
<p><strong>简单版:</strong></p>
<p>首先得把函数传进来把，不然你New个头。</p>
<p>然后得把参数传过来把。怎么传？简单点，返回一个函数再传参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//随便写一个构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age </span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> o = &#123;<span class="string">"__proto__"</span>:f.prototype&#125;;</div><div class="line">		f.apply( o,<span class="built_in">arguments</span> );</div><div class="line">		<span class="keyword">return</span> o;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p1 = New(Person)(<span class="string">"zjl"</span>,<span class="number">33</span>);</div><div class="line">alert(p1.name);</div></pre></td></tr></table></figure>
<p>显然传进来一个函数再接受参数的方式看起来不舒服。咱改造改造。</p>
<p>把所有参数一次性都传过来，来者不拒。毕竟咱有<code>arguments</code>这么强大的东西。</p>
<p>但怎么也得规范一下把，不能把参数先写到前面。毕竟函数是老大，其他都是小弟，得在后面。</p>
<p>之后就利用call和apply的特性，写起来其实和上面差不多。</p>
<p><strong>复杂版:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name </span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> objectFactory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();<span class="comment">// 从 Object.prototype 上克隆一个空的对象</span></div><div class="line">	<span class="comment">// arguments  = [function function, "sven"];</span></div><div class="line">	Constructor = [].shift.call( <span class="built_in">arguments</span> ); <span class="comment">// 取得外部传入的构造器，此时Constructor是Person函数</span></div><div class="line">	obj.__proto__ = Constructor.prototype; <span class="comment">// 指向正确的原型</span></div><div class="line">	<span class="comment">// arguments  = ["sven"];</span></div><div class="line">	<span class="keyword">var</span> ret = Constructor.apply( obj, <span class="built_in">arguments</span> ); <span class="comment">// 借用外部传入的构造器给 obj 设置属性</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">'object'</span> ? ret : obj; <span class="comment">// 确保构造器总是会返回一个对象</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = objectFactory( Person, <span class="string">'sven'</span> );</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( a.name ); <span class="comment">// 输出：sven</span></div><div class="line"><span class="built_in">console</span>.log( a.getName() ); <span class="comment">// 输出：sven</span></div><div class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.getPrototypeOf( a ) === Person.prototype ); <span class="comment">// 输出：true</span></div></pre></td></tr></table></figure>
<p>值得注意的是<code>arguments</code>是一个类数组，不能直接操作。所以得借用数组的方法。</p>
<h2 id="call-apply的模拟"><a href="#call-apply的模拟" class="headerlink" title="call,apply的模拟"></a>call,apply的模拟</h2><p>call，apply两者就是方法参数不一样，一个是数组，一个是一个个传的。</p>
<p>实现原理基本是给this指向的对象绑定该方法，设置参数调用eval魔术方法，最后使用delete删除方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</div><div class="line">    context.fn = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> args = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</div><div class="line">        args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args +<span class="string">')'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> context.fn</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> context = [].shift.call(<span class="built_in">arguments</span>) || <span class="built_in">window</span>;</div><div class="line">	<span class="keyword">var</span> args  = [].shift.call(<span class="built_in">arguments</span>) || [];</div><div class="line">	<span class="keyword">var</span> arr =[];</div><div class="line">	context.fn = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, l = args .length; i &lt; l ; i++ )&#123;</div><div class="line">		arr.push(<span class="string">'args['</span>+ i +<span class="string">']'</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span>+ arr+<span class="string">')'</span>);</div><div class="line"></div><div class="line">	<span class="keyword">delete</span> context.fn;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="bind的模拟"><a href="#bind的模拟" class="headerlink" title="bind的模拟"></a>bind的模拟</h2><p>上面是call,apply模拟。bind就是返回一个函数call。bind只不过做了个闭包，延迟调用，其他就没什么了。</p>
<p><strong>简单版</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// 保存原函数</span></div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 返回一个新的函数</span></div><div class="line">		<span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>); <span class="comment">// 执行新的函数的时候，会把之前传入的 context</span></div><div class="line">		<span class="comment">// 当作新函数体内的 this</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此类只能解决传递改变this的问题。不能处理多参数。很简单，对argument进行处理</p>
<p><strong>复杂版</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span>, <span class="comment">// 保存原函数</span></div><div class="line">		context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">// 需要绑定的 this 上下文</span></div><div class="line">		args = [].slice.call(<span class="built_in">arguments</span>); <span class="comment">// 剩余的参数转成数组</span></div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 返回一个新的函数</span></div><div class="line">		<span class="keyword">return</span> self.apply(context, [].concat.call(args, [].slice.call(<span class="built_in">arguments</span>)));</div><div class="line">		<span class="comment">// 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this</span></div><div class="line">		<span class="comment">// 并且组合两次分别传入的参数，作为新函数的参数</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//测试</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">'sven'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d</span>) </span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.name); </div><div class="line">	alert([a, b, c, d]) </div><div class="line">&#125;.bind(obj, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line">func(<span class="number">3</span>, <span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="comment">//猜猜输出什么。</span></div></pre></td></tr></table></figure>
<h2 id="Object-create的模拟"><a href="#Object-create的模拟" class="headerlink" title="Object.create的模拟"></a>Object.create的模拟</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.create = <span class="built_in">Object</span>.create || <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">	F.prototype = obj;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/11/20/JS中常用方法的模拟/" data-id="cj8lswfmh000p5svbuzxmftk8" class="article-share-link" data-share="baidu" data-title="JS中常用方法的模拟">Share</a>
      

      
        <a href="http://yoursite.com/2016/11/20/JS中常用方法的模拟/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS 核心之 变量对象（Variable Object）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/18/JS 核心之 变量对象（Variable Object）/" class="article-date">
  <time datetime="2016-11-18T05:59:55.000Z" itemprop="datePublished">2016-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/18/JS 核心之 变量对象（Variable Object）/">变量对象（Variable Object）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>大多数ECMAScript程序员应该都知道变量与执行上下文有密切关系：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// 全局上下文中的变量</span></div><div class="line"> </div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// function上下文中的局部变量</span></div><div class="line">&#125;)();</div><div class="line"> </div><div class="line">alert(a); <span class="comment">// 10</span></div><div class="line">alert(b); <span class="comment">// 全局变量 "b" 没有声明</span></div></pre></td></tr></table></figure>
<p>并且，很多程序员也都知道，当前ECMAScript规范指出独立作用域只能通过“函数(function)”代码类型的执行上下文创建。也就是说，相对于C/C++来说，ECMAScript里的for循环并不能创建一个局部的上下文。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123;</div><div class="line">  alert(k);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">alert(k); <span class="comment">// 尽管循环已经结束但变量k依然在当前作用域</span></div></pre></td></tr></table></figure>
<p>我们来看看一下，我们声明数据的时候到底都发现了什么细节。</p>
<h2 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h2><p>如果变量与执行上下文相关，那变量自己应该知道它的数据存储在哪里，并且知道如何访问。这种机制称为变量对象(variable object)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">变量对象(缩写为VO)是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：</div><div class="line">    变量 (<span class="keyword">var</span>, 变量声明);</div><div class="line">    函数声明 (FunctionDeclaration, 缩写为FD);</div><div class="line">    函数的形参</div></pre></td></tr></table></figure>
<p>就像执行上下文所说的, VO就是执行上下文的属性(property)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">activeExecutionContext = &#123;</div><div class="line">  <span class="attr">VO</span>: &#123;</div><div class="line">    <span class="comment">// 上下文数据（var, FD, function arguments)</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>只有全局上下文的变量对象允许通过VO的属性名称来间接访问(因为在全局上下文里，全局对象自身就是变量对象，稍后会详细介绍)，在其它上下文中是不能直接访问VO对象的，因为它只是内部机制的一个实现。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">test(<span class="number">30</span>);</div></pre></td></tr></table></figure>
<p>对应的变量对象是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局上下文的变量对象</span></div><div class="line">VO(globalContext) = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">10</span>,</div><div class="line">  <span class="attr">test</span>: &lt;reference to function&gt;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// test函数上下文的变量对象</div><div class="line">VO(test functionContext) = &#123;</div><div class="line">  x: 30,</div><div class="line">  b: 20</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="不同执行上下文中的变量对象"><a href="#不同执行上下文中的变量对象" class="headerlink" title="不同执行上下文中的变量对象"></a>不同执行上下文中的变量对象</h2><p>对于所有类型的执行上下文来说，变量对象的一些操作(如变量初始化)和行为都是共通的。从这个角度来看，把变量对象作为抽象的基本事物来理解更为容易。同样在函数上下文中也定义和变量对象相关的额外内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">抽象变量对象VO (变量初始化过程的一般行为)</div><div class="line">  ║</div><div class="line">  ╠══&gt; 全局上下文变量对象GlobalContextVO</div><div class="line">  ║        (VO === <span class="keyword">this</span> === global)</div><div class="line">  ║</div><div class="line">  ╚══&gt; 函数上下文变量对象FunctionContextVO</div><div class="line">           (VO === AO, 并且添加了&lt;<span class="built_in">arguments</span>&gt;和&lt;formal parameters&gt;)</div></pre></td></tr></table></figure>
<p>我们来详细看一下：</p>
<h2 id="全局上下文中的变量对象"><a href="#全局上下文中的变量对象" class="headerlink" title="全局上下文中的变量对象"></a><strong>全局上下文中的变量对象</strong></h2><p>首先，我们要给全局对象一个明确的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">全局对象(Global object) 是在进入任何执行上下文之前就已经创建了的对象；</div><div class="line">这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。</div></pre></td></tr></table></figure>
<p>全局对象初始创建阶段将Math、String、Date、parseInt作为自身属性，等属性初始化，同样也可以有额外创建的其它对象作为属性（其可以指向到全局对象自身）。例如，在DOM中，全局对象的window属性就可以引用全局对象自身(当然，并不是所有的具体实现都是这样)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">global = &#123;</div><div class="line">  <span class="attr">Math</span>: &lt;...&gt;,</div><div class="line">  String: &lt;...&gt;</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  window: global //引用自身</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当访问全局对象的属性时通常会忽略掉前缀，这是因为全局对象是不能通过名称直接访问的。不过我们依然可以通过全局上下文的this来访问全局对象，同样也可以递归引用自身。例如，DOM中的window。综上所述，代码可以简写为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>(<span class="number">10</span>); <span class="comment">// 就是global.String(10);</span></div><div class="line"> </div><div class="line"><span class="comment">// 带有前缀</span></div><div class="line"><span class="built_in">window</span>.a = <span class="number">10</span>; <span class="comment">// === global.window.a = 10 === global.a = 10;</span></div><div class="line"><span class="keyword">this</span>.b = <span class="number">20</span>; <span class="comment">// global.b = 20;</span></div></pre></td></tr></table></figure>
<p>因此，回到全局上下文中的变量对象——在这里，变量对象就是全局对象自己：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO(globalContext) === global;</div></pre></td></tr></table></figure>
<p>非常有必要要理解上述结论，基于这个原理，在全局上下文中声明的对应，我们才可以间接通过全局对象的属性来访问它（例如，事先不知道变量名称）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>);</div><div class="line"> </div><div class="line">alert(a); <span class="comment">// 直接访问，在VO(globalContext)里找到："test"</span></div><div class="line"> </div><div class="line">alert(<span class="built_in">window</span>[<span class="string">'a'</span>]); <span class="comment">// 间接通过global访问：global === VO(globalContext): "test"</span></div><div class="line">alert(a === <span class="keyword">this</span>.a); <span class="comment">// true</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> aKey = <span class="string">'a'</span>;</div><div class="line">alert(<span class="built_in">window</span>[aKey]); <span class="comment">// 间接通过动态属性名称访问："test"</span></div></pre></td></tr></table></figure>
<h2 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a><strong>函数上下文中的变量对象</strong></h2><p>在函数执行上下文中，VO是不能直接访问的，此时由活动对象(activation object,缩写为AO)扮演VO的角色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO(functionContext) === AO;</div></pre></td></tr></table></figure>
<p>活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。arguments属性的值是Arguments对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AO = &#123;</div><div class="line">  <span class="attr">arguments</span>: &lt;ArgO&gt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Arguments对象是活动对象的一个属性，它包括如下属性：</p>
<ol>
<li>callee — 指向当前函数的引用</li>
<li>length — 真正传递的参数个数</li>
<li>properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes内部元素的个数等于arguments.length. properties-indexes 的值和实际传递进来的参数之间是共享的。</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</div><div class="line"> </div><div class="line">  <span class="comment">// 声明的函数参数数量arguments (x, y, z)</span></div><div class="line">  alert(foo.length); <span class="comment">// 3</span></div><div class="line"> </div><div class="line">  <span class="comment">// 真正传进来的参数个数(only x, y)</span></div><div class="line">  alert(<span class="built_in">arguments</span>.length); <span class="comment">// 2</span></div><div class="line"> </div><div class="line">  <span class="comment">// 参数的callee是函数自身</span></div><div class="line">  alert(<span class="built_in">arguments</span>.callee === foo); <span class="comment">// true</span></div><div class="line"> </div><div class="line">  <span class="comment">// 参数共享</span></div><div class="line"> </div><div class="line">  alert(x === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></div><div class="line">  alert(x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">20</span>;</div><div class="line">  alert(x); <span class="comment">// 20</span></div><div class="line"> </div><div class="line">  x = <span class="number">30</span>;</div><div class="line">  alert(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 30</span></div><div class="line"> </div><div class="line">  <span class="comment">// 不过，没有传进来的参数z，和参数的第3个索引值是不共享的</span></div><div class="line"></div><div class="line">  z = <span class="number">40</span>;</div><div class="line">  alert(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// undefined</span></div><div class="line"> </div><div class="line">  <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">50</span>;</div><div class="line">  alert(z); <span class="comment">// 40</span></div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</div></pre></td></tr></table></figure>
<h2 id="处理上下文代码的2个阶段"><a href="#处理上下文代码的2个阶段" class="headerlink" title="处理上下文代码的2个阶段"></a>处理上下文代码的2个阶段</h2><p>现在我们终于到了本文的核心点了。执行上下文的代码被分成两个基本的阶段来处理：</p>
<ol>
<li>进入执行上下文</li>
<li>执行代码</li>
</ol>
<p>变量对象的修改变化与这两个阶段紧密相关。</p>
<p>注：这2个阶段的处理是一般行为，和上下文的类型无关（也就是说，在全局上下文和函数上下文中的表现是一样的）。</p>
<h2 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a><strong>进入执行上下文</strong></h2><p>当进入执行上下文(代码执行之前)时，VO里已经包含了下列属性(前面已经说了)：</p>
<pre><code>**函数的所有形参(如果我们是在函数执行上下文中)**

— 由名称和对应值组成的一个变量对象的属性被创建；没有传递对应参数的话，那么由名称和undefined值组成的一种变量对象的属性也将被创建。

**所有函数声明(FunctionDeclaration, FD)**

—由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；**如果变量对象已经存在相同名称的属性，则完全替换这个属性。**

**所有变量声明(var, VariableDeclaration)**

— 由名称和对应值（undefined）组成一个变量对象的属性被创建；**如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。**
</code></pre><p>让我们看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> c = <span class="number">10</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">  <span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">test(<span class="number">10</span>); <span class="comment">// call</span></div></pre></td></tr></table></figure>
<p>当进入带有参数10的test函数上下文时，AO表现为如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AO(test) = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">10</span>,</div><div class="line">  <span class="attr">b</span>: <span class="literal">undefined</span>,</div><div class="line">  <span class="attr">c</span>: <span class="literal">undefined</span>,</div><div class="line">  <span class="attr">d</span>: &lt;reference to FunctionDeclaration "d"&gt;</div><div class="line">  e: undefined</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这之后，将进入处理上下文代码的第二个阶段 — 执行代码。</p>
<h2 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h2><p>这个周期内，AO/VO已经拥有了属性(不过，并不是所有的属性都有值，大部分属性的值还是系统默认的初始值undefined )。</p>
<p>还是前面那个例子, AO/VO在代码解释期间被修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AO[<span class="string">'c'</span>] = <span class="number">10</span>;</div><div class="line">AO[<span class="string">'e'</span>] = &lt;reference to FunctionExpression "_e"&gt;;</div></pre></td></tr></table></figure>
<p>另一个经典例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">alert(x); <span class="comment">// function</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line">alert(x); <span class="comment">// 10</span></div><div class="line"> </div><div class="line">x = <span class="number">20</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"> </div><div class="line">alert(x); <span class="comment">// 20</span></div></pre></td></tr></table></figure>
<p>为什么第一个alert “x” 的返回值是function，而且它还是在“x” 声明之前访问的“x” 的？为什么不是10或20呢？因为，根据规范函数声明是在当<strong>进入上下文</strong>时填入的； 同一周期，在进入上下文的时候还有一个变量声明“x”，那么正如我们在上一个阶段所说，<strong>变量声明在顺序上跟在函数声明和形式参数声明之后</strong>，而且在这个<strong>进入上下文</strong>阶段，<strong>变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明</strong>，因此，在进入上下文时，VO的结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">VO = &#123;&#125;;</div><div class="line"> </div><div class="line">VO[<span class="string">'x'</span>] = &lt;reference to FunctionDeclaration "x"&gt;</div><div class="line"> </div><div class="line">// 找到var x = 10;</div><div class="line">// 如果function "x"没有已经声明的话</div><div class="line">// 这时候"x"的值应该是undefined</div><div class="line">// 但是这个case里变量声明没有影响同名的function的值</div><div class="line"> </div><div class="line">VO['x'] = &lt;the value is not disturbed, still function&gt;</div></pre></td></tr></table></figure>
<p>紧接着，<strong>在执行代码阶段</strong>，VO做如下修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">VO[<span class="string">'x'</span>] = <span class="number">10</span>;</div><div class="line">VO[<span class="string">'x'</span>] = <span class="number">20</span>;</div></pre></td></tr></table></figure>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>不同执行上下文中的变量对象，<br>  ║<br>  ╠══&gt; 全局上下文变量对象GlobalContextVO<br>  ║        (VO === this === global)<br>  ║<br>  ╚══&gt; 函数上下文变量对象FunctionContextVO</p>
<p>​           (VO === AO, 并且添加了<code>arguments</code>和<code>formal parameters</code>)</p>
<p>执行代码分成两个阶段</p>
<ol>
<li>进入执行上下文</li>
<li>执行代码</li>
</ol>
<p>进入执行上下文时会<strong>按顺序</strong>初始化变量和函数声明——-这也就是我们一般所说的变量提升。。</p>
<p>​    函数的所有形参 &gt; 函数声明 &gt; 变量声明</p>
<p>好了，作业来了，看看这两个分别输出什么。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (!foo) &#123;  </div><div class="line">        <span class="keyword">var</span> foo = <span class="number">10</span>;  </div><div class="line">    &#125;  </div><div class="line">    alert(foo);  </div><div class="line">&#125;  </div><div class="line">bar();</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    a = <span class="number">10</span>;  </div><div class="line">    <span class="keyword">return</span>;  </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;  </div><div class="line">&#125;  </div><div class="line">b();  </div><div class="line">alert(a);</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/11/18/JS 核心之 变量对象（Variable Object）/" data-id="cj8lswfmd000i5svbpmgqxsjo" class="article-share-link" data-share="baidu" data-title="变量对象（Variable Object）">Share</a>
      

      
        <a href="http://yoursite.com/2016/11/18/JS 核心之 变量对象（Variable Object）/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-es6学习之Generator函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/18/es6学习之Generator函数/" class="article-date">
  <time datetime="2016-11-18T03:25:55.000Z" itemprop="datePublished">2016-11-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/es6/">es6</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/18/es6学习之Generator函数/">es6 学习之 Generator 函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是Generator？"><a href="#什么是Generator？" class="headerlink" title="什么是Generator？"></a>什么是Generator？</h2><p>generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'world'</span>;</div><div class="line">	<span class="keyword">return</span> <span class="string">'ending'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> hw = helloWorldGenerator();<span class="comment">//调用之后是没有任何输出的。。</span></div></pre></td></tr></table></figure>
<p>上面就是一个<code>generator</code>,形式上，Generator函数是一个普通函数，但是有两个特征。</p>
<p>一是， function 关键字与函数名之间有一个<strong>星号</strong>；</p>
<p>二是，函数体内部使用 yield 语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）</p>
<p>Generator函数有多种理解角度。从语法上，首先可以把它理解成，<strong>Generator函数是一个状态机，封装了多个内部状态。</strong></p>
<p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>
<p>调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象。</p>
<p>下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 语句（或 return 语句）为止。换言之，Generator函数是分段执行的， yield 语句是暂停执行的标记，而 next 方法可以恢复执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></div><div class="line">hw.next()</div><div class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></div></pre></td></tr></table></figure>
<p>总结一下.</p>
<ol>
<li><strong>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。</strong></li>
<li><strong>以后，每次调用遍历器对象的 <code>next</code> 方法，就会返回一个有着 <code>value</code> 和<code>done</code>两个属性的对象。</strong></li>
<li><strong>value 属性表示当前的内部状态的值，是 yield 语句后面那个表达式的值. done 属性是一个布尔值，表示是否遍历结束。</strong></li>
</ol>
<h2 id="next参数"><a href="#next参数" class="headerlink" title="next参数"></a>next参数</h2><ol>
<li><p><strong>yield 语句本身没有返回值，或者说总是返回 undefined 。</strong> </p>
<p><strong>yield 语句本身没有返回值，或者说总是返回 undefined 。</strong> </p>
<p><strong>yield 语句本身没有返回值，或者说总是返回 undefined 。</strong> </p>
</li>
<li><p><strong>next 方法可以带一个参数，该参数就会被当作上一个 yield 语句的返回值。</strong></p>
<p><strong>也就意味着你第一次next不能带参数，或则只能带undefined。</strong></p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">	<span class="built_in">console</span>.log( a );</div><div class="line">	<span class="keyword">var</span> b = <span class="keyword">yield</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line">g = fn();</div><div class="line"></div><div class="line">g.next()</div><div class="line"><span class="comment">//&#123;value: 1, done: false&#125;</span></div><div class="line">g.next(<span class="number">2</span>)</div><div class="line"><span class="comment">// console.log 会打印 undefined</span></div><div class="line"><span class="comment">// &#123;value: undefined, done: false&#125; value值也会是undefined</span></div></pre></td></tr></table></figure>
<p>这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 next 方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
<h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><p>for…of 循环可以自动遍历调用Generator函数时生成的Iterator对象，且此时不再需要调用 next 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">4</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</div><div class="line">	<span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1 2 3</span></div></pre></td></tr></table></figure>
<p>这里需要注意，<br><strong>一旦 next 方法的返回对象的 done 属性为 true ， for…of 循环就会中止，且不包含该返回对象，</strong>所以上面代码的 return 语句返回的6，不包括在 for…of 循环之中。</p>
<h2 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield*语句"></a>yield*语句</h2><p>如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'a'</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'b'</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="string">'x'</span>;</div><div class="line">	foo();</div><div class="line">	<span class="keyword">yield</span> <span class="string">'y'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar())&#123;</div><div class="line">	<span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="comment">// "x"</span></div><div class="line"><span class="comment">// "y" 4 5</span></div><div class="line"></div><div class="line"><span class="comment">// foo 和 bar 都是Generator函数，在 bar 里面调用 foo ，是不会有效果的。</span></div></pre></td></tr></table></figure>
<p>这个就需要用到 yield* 语句，用来在一个Generator函数里面执行另一个Generator函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'x'</span>;</div><div class="line">    <span class="keyword">yield</span> * foo();</div><div class="line">    <span class="keyword">yield</span> <span class="string">'y'</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'x'</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</div><div class="line">        <span class="keyword">yield</span> v;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'y'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="function"><span class="keyword">function</span> * <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'x'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'a'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'b'</span>;</div><div class="line">    <span class="keyword">yield</span> <span class="string">'y'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="comment">// "x"</span></div><div class="line"><span class="comment">// "a"</span></div><div class="line"><span class="comment">// "b"</span></div><div class="line"><span class="comment">// "y"</span></div></pre></td></tr></table></figure>
<p><strong><code>yield*</code>后面的Generator函数，等同于在Generator函数内部，部署一个 for…of 循环</strong>。</p>
<p><strong>如果后面的Generator函数有return语句那么 <code>yield*</code>语句返回的就是该值。但不影响正常执行</strong></p>
<p><strong>本人技术有限，且技术更新很快，如果文中存在错误或者不足，欢迎大家指正，相互交流。</strong></p>
<p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6 入门</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/11/18/es6学习之Generator函数/" data-id="cj8lswfmz001e5svbl2cl7biy" class="article-share-link" data-share="baidu" data-title="es6 学习之 Generator 函数">Share</a>
      

      
        <a href="http://yoursite.com/2016/11/18/es6学习之Generator函数/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/">es6</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/">Node</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 17.5px;">JavaScript</a> <a href="/tags/Node/" style="font-size: 20px;">Node</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/es6/" style="font-size: 12.5px;">es6</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/tools/" style="font-size: 12.5px;">tools</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/15/koa-router小笔记/">koa-router小笔记</a>
          </li>
        
          <li>
            <a href="/2017/09/10/一些源码分析解析/">一些npm包源码分析</a>
          </li>
        
          <li>
            <a href="/2017/09/02/fiddler/">fiddler抓包工具</a>
          </li>
        
          <li>
            <a href="/2017/05/02/这些年我用过的软件/">那些年我用过的软件</a>
          </li>
        
          <li>
            <a href="/2017/04/02/利用pipe处理并发/">利用pipe处理并发的可行性</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 ChenXing<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="totop"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
