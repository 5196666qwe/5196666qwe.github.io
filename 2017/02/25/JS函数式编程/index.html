<!DOCTYPE html>
<html lang="en">
<head>
  <!-- content-Type -->
<meta charset="utf-8">


<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="renderer" content="webkit|ie-comp|ie-stand">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="language" content="en">
<meta name="robots" content="all">


<meta content="yes" name="apple-mobile-web-app-capable">
<meta content="black" name="apple-mobile-web-app-status-bar-style">
<meta content="telephone=no" name="format-detection">
<meta content="email=no" name="format-detection">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






<meta name="google-site-verification" content="xxxxxxxxxx" />




<meta name="baidu-site-verification" content="xxxxxxxxxx" />







<meta name="keywords" content="JavaScript," />


<meta name="description" content="以前一直听过函数式编程的大名，不过也没去了解。总感觉很牛逼的样子，这几天偶然在gitbook上发现一本书JS函数式编程指南，开始是因为它星星比较多，下载过来收藏一下。后来在家闲的无聊，看了看，，，对，我也就看了看。。
引用某乎对函数式编程的一个解释，和我看的这本书所阐述的不谋而合。
一.简介编程范式
函数式编程是一种编程范式，我们常见的编程范式有命令式编程（Imperative programmi">
<meta property="og:type" content="article">
<meta property="og:title" content="JS函数式编程-入坑指南">
<meta property="og:url" content="http://yoursite.com/2017/02/25/JS函数式编程/index.html">
<meta property="og:site_name" content="ChenXing">
<meta property="og:description" content="以前一直听过函数式编程的大名，不过也没去了解。总感觉很牛逼的样子，这几天偶然在gitbook上发现一本书JS函数式编程指南，开始是因为它星星比较多，下载过来收藏一下。后来在家闲的无聊，看了看，，，对，我也就看了看。。
引用某乎对函数式编程的一个解释，和我看的这本书所阐述的不谋而合。
一.简介编程范式
函数式编程是一种编程范式，我们常见的编程范式有命令式编程（Imperative programmi">
<meta property="og:image" content="http://yoursite.com/img/fp/fp.png">
<meta property="og:updated_time" content="2017-03-06T06:32:37.744Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS函数式编程-入坑指南">
<meta name="twitter:description" content="以前一直听过函数式编程的大名，不过也没去了解。总感觉很牛逼的样子，这几天偶然在gitbook上发现一本书JS函数式编程指南，开始是因为它星星比较多，下载过来收藏一下。后来在家闲的无聊，看了看，，，对，我也就看了看。。
引用某乎对函数式编程的一个解释，和我看的这本书所阐述的不谋而合。
一.简介编程范式
函数式编程是一种编程范式，我们常见的编程范式有命令式编程（Imperative programmi">
<meta name="twitter:image" content="http://yoursite.com/img/fp/fp.png">






  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />






<link href="http://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


<script>
(function(){
  var bp = document.createElement('script');
  bp.src = '//push.zhanzhang.baidu.com/push.js';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script>

  <title> JS函数式编程-入坑指南 </title>
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'xxxxxxxxxx', 'auto');
  ga('send', 'pageview');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?1551fdd18711ccb1c048bb11f579b1a4";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



</head>
<body lang="zh-Hans">

  <!--[if lte IE 9]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->


  <div class="another-theme layout">

    
<header class="header" id="header">

  <div class="header-cont">
    <div class="text-area">
      
        <h1 class="title" data-text="JS函数式编程-入坑指南"> JS函数式编程-入坑指南 </h1>

        
        <div class="post-meta">
          <div class="post-time">
            发表于
            <time  datetime="2017-02-25T14:59:55+08:00" content="2017-02-25">
              2017-02-25
            </time>
          </div>

          
            <div class="post-category" >
              
                <span>
                  <a href="/categories#JavaScript" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                

              
            </div>
          

          
            
          
        </div>
        
      
    </div>
    <!-- Navigation -->
    
    <nav class="navigation clearfix" id="navigation">
      
        
        <a class="nav-link" href="/" rel="section">
          首页
        </a>
      
        
        <a class="nav-link" href="/tags" rel="section">
          标签
        </a>
      
        
        <a class="nav-link" href="/categories" rel="section">
          分类
        </a>
      
        
        <a class="nav-link" href="/about" rel="section">
          关于
        </a>
      
    </nav>
    
  </div>
  <div class="mask"></div>
</header>


    <main class="container">

      

  <article class="post-article post-type-normal post" itemscope>

  <div class="post-body">

    <div class="content markdown-body"><p>以前一直听过函数式编程的大名，不过也没去了解。总感觉很牛逼的样子，这几天偶然在<code>gitbook</code>上发现一本书<code>JS函数式编程指南</code>，开始是因为它星星比较多，下载过来收藏一下。后来在家闲的无聊，看了看，，，对，我也就看了看。。</p>
<p>引用某乎对函数式编程的一个解释，和我看的这本书所阐述的不谋而合。</p>
<h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h2><p><strong>编程范式</strong></p>
<p>函数式编程是一种编程范式，我们常见的编程范式有<strong>命令式编程（Imperative programming），函数式编程，逻辑式编程</strong>，常见的面向对象编程是也是一种命令式编程。</p>
<p>命令式编程是面向<strong>计算机硬件</strong>的抽象，有<strong>变量</strong>（对应着存储单元，<strong>赋值语句</strong>（获取，存储指令），<strong>表达式</strong>（内存引用和算术运算）和<strong>控制语句</strong>（跳转指令），一句话，命令式程序就是一个<strong>冯诺依曼机的指令序列</strong>。</p>
<p>而函数式编程是面向数学的抽象，将计算描述为一种<strong>表达式求值</strong>，一句话，函数式程序就是一个<strong>表达式</strong>。</p>
<p><strong>函数式编程的本质</strong></p>
<p>函数式编程中的<strong>函数</strong>这个术语不是指计算机中的函数（实际上是<strong>Subroutine</strong>），而是<strong>指数学中的函数</strong>，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。</p>
<p>在函数式语言中，<strong>函数作为一等公民</strong>，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行组合。</p>
<p>纯函数式编程语言中的变量也不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即一个值的名称。变量的值是<strong>不可变</strong>的（immutable），也就是说不允许像命令式编程语言中那样多次给一个变量赋值。比如说在命令式编程语言我们写“x = x + 1”，这依赖可变状态的事实，拿给程序员看说是对的，但拿给数学家看，却被认为这个等式为假。</p>
<p>函数式语言的如条件语句，循环语句也不是命令式编程语言中的<strong>控制语句</strong>，而是函数的语法糖，比如在Scala语言中，if else不是语句而是三元运算符，是有返回值的。</p>
<p>严格意义上的函数式编程意味着不使用可变的变量，赋值，循环和其他命令式控制结构进行编程。</p>
<p>从理论上说，函数式语言也不是通过冯诺伊曼体系结构的机器上运行的，而是通过λ演算来运行的，就是通过变量替换的方式进行，变量替换为其值或表达式，函数也替换为其表达式，并根据运算符进行计算。λ演算是图灵完全（Turing completeness）的，但是大多数情况，函数式程序还是被编译成（冯诺依曼机的）机器语言的指令执行的。</p>
<p><strong>函数式编程的好处</strong></p>
<p>由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处主要是不可变性带来的。没有可变的状态，函数就是<strong>引用透明</strong>（Referential transparency）的和<strong>没有副作用</strong>（No Side Effect）。</p>
<p>一个好处是，函数即不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。</p>
<p>不变性带来的另一个好处是：由于（多个线程之间）不共享状态，不会造成<strong>资源争用</strong>(Race condition)，也就不需要用锁来保护可变状态，也就不会出现死锁，这样可以更好地并发起来，尤其是在对称<strong>多处理器</strong>（SMP）架构下能够更好地利用多个处理器（核）提供的并行处理能力。</p>
<p><strong>函数式编程的特性</strong></p>
<ul>
<li><strong>高阶函数（Higher-order function）</strong>：参数为函数或返回值为函数的函数</li>
<li><strong>偏应用函数（Partially Applied Functions）</strong>：函数是用来当做模板来生产出函数的</li>
<li><strong>柯里化（Currying）</strong>：部分求值函数</li>
<li><strong>闭包（Closure）</strong>：</li>
</ul>
<h2 id="二-一个简单例子的开始"><a href="#二-一个简单例子的开始" class="headerlink" title="二.一个简单例子的开始"></a>二.一个简单例子的开始</h2><p><strong>函数式编程里函数指的是数学里的函数。</strong></p>
<p>我们从一个愚蠢的例子开始。下面是一个海鸥程序，鸟群合并则变成了一个更大的鸟群，繁殖则增加了鸟群的数量，增加的数量就是它们繁殖出来的海鸥的数量。注意这个程序并不是面向对象的良好实践，它只是强调当前这种变量赋值方式的一些弊端。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Flock = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.seagulls = n;</div><div class="line">&#125;;</div><div class="line">Flock.prototype.conjoin = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.seagulls += other.seagulls;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line">Flock.prototype.breed = <span class="function"><span class="keyword">function</span> (<span class="params">other</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.seagulls = <span class="keyword">this</span>.seagulls * other.seagulls;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> flock_a = <span class="keyword">new</span> Flock(<span class="number">4</span>);</div><div class="line"><span class="keyword">var</span> flock_b = <span class="keyword">new</span> Flock(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> flock_c = <span class="keyword">new</span> Flock(<span class="number">0</span>);</div><div class="line"><span class="keyword">var</span> result = flock_a.conjoin(flock_c).breed(flock_b).conjoin(flock_a.breed(flock_b)).seagulls;</div><div class="line"><span class="comment">//=&gt; 32</span></div></pre></td></tr></table></figure>
<p>我们期望是答案是16，但是 js 因为有 this 的存在，你会发现是 32 .如果你看不懂这个程序，没关系，我也看不懂。重点是状态和可变值非常难以追踪，即便是在这么小的一个程序中也不例外。</p>
<p>我们试试另一种更函数式的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> conjoin = <span class="function"><span class="keyword">function</span>(<span class="params">flock_x, flock_y</span>) </span>&#123; <span class="keyword">return</span> flock_x + flock_y &#125;;</div><div class="line"><span class="keyword">var</span> breed = <span class="function"><span class="keyword">function</span>(<span class="params">flock_x, flock_y</span>) </span>&#123; <span class="keyword">return</span> flock_x * flock_y &#125;;</div><div class="line"><span class="keyword">var</span> flock_a = <span class="number">4</span>;</div><div class="line"><span class="keyword">var</span> flock_b = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> flock_c = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> result = conjoin(breed(flock_b, conjoin(flock_a, flock_c)),breed(flock_a, flock_b));</div><div class="line"><span class="comment">//=&gt;16</span></div></pre></td></tr></table></figure>
<p>再深入挖掘，看看这段代码究竟做了什么事，我们会发现，它不过是在进行简单的加（ conjoin ） 和乘（ breed ）运算而已。代码中的两个函数除了函数名有些特殊，其他没有任何难以理解的地方。我们把它们重命名一下，看看它们的真面目。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y &#125;;</div><div class="line"><span class="keyword">var</span> multiply = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x * y &#125;;</div><div class="line"><span class="keyword">var</span> flock_a = <span class="number">4</span>;</div><div class="line"><span class="keyword">var</span> flock_b = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> flock_c = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> result = add(multiply(flock_b, add(flock_a, flock_c)), multiply(flock_a, flock_b));</div><div class="line"><span class="comment">//=&gt;16</span></div></pre></td></tr></table></figure>
<p>这么一来，你会发现我们不过是在运用古人早已获得的知识：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 结合律（assosiative）</span></div><div class="line">add(add(x, y), z) == add(x, add(y, z));</div><div class="line"><span class="comment">// 交换律（commutative）</span></div><div class="line">add(x, y) == add(y, x);</div><div class="line"><span class="comment">// 同一律（identity）</span></div><div class="line">add(x, <span class="number">0</span>) == x;</div><div class="line"><span class="comment">// 分配律（distributive）</span></div><div class="line">multiply(x, add(y,z)) == add(multiply(x, y), multiply(x, z));</div></pre></td></tr></table></figure>
<p>我们来看看能否运用这些定律重构这个海鸥小程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原有代码</span></div><div class="line">add(multiply(flock_b, add(flock_a, flock_c)), multiply(flock_a,flock_b));</div><div class="line"><span class="comment">// 应用同一律，去掉多余的加法操作（add(flock_a, flock_c) == flock_a）(flock_c = 0 )</span></div><div class="line">add(multiply(flock_b, flock_a), multiply(flock_a, flock_b));</div><div class="line"><span class="comment">// 再应用分配律</span></div><div class="line">multiply(flock_b, add(flock_a, flock_a));</div></pre></td></tr></table></figure>
<p>漂亮！除了调用的函数，一点多余的代码都不需要写。当然这里我们定义 add 和multiply 是为了代码完整性，实际上并不必要——在调用之前它们肯定已经在某个类库里定义好了。</p>
<p>你可能在想“你也太偷换概念了吧，居然举一个这么数学的例子”，或者“真实世界的应用程序比这复杂太多，不能这么简单地推理”。我之所以选择这样一个例子，是因为大多数人都知道加法和乘法，所以很容易就能理解数学可以如何为我们所用。</p>
<h2 id="二-函数第一等公民和纯函数的好处"><a href="#二-函数第一等公民和纯函数的好处" class="headerlink" title="二.函数第一等公民和纯函数的好处"></a>二.函数第一等公民和纯函数的好处</h2><p>当我们说函数是“一等公民”的时候，实际上说的是它们和其他对象都一样…所以就是普通公民（坐经济舱的人？）函数真没什么特殊的，你可以像对待任何其他数据类型一样对待它们——把它们存在数组里，当作参数传递，赋值给变量…等等。</p>
<p>我们来看一个杜撰的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hi = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">"Hi "</span> + name;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> greeting = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> hi(name);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里 greeting 指向的那个把 hi 包了一层的包裹函数完全是多余的。 greeting 只不过是转了个身然后以相同的参数调用了 hi 函数而已，因此我们可以这么写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greeting = hi;</div><div class="line">greeting(<span class="string">"times"</span>);</div><div class="line"><span class="comment">// "Hi times"</span></div></pre></td></tr></table></figure>
<p>用一个函数把另一个函数包起来，目的仅仅是延迟执行，真的是非常糟糕的编程习惯</p>
<p>再来看几个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 太傻了</span></div><div class="line"><span class="keyword">var</span> getServerStuff = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> ajaxCall(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> callback(json);</div><div class="line">	&#125;);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 这才像样</span></div><div class="line"><span class="keyword">var</span> getServerStuff = ajaxCall;</div></pre></td></tr></table></figure>
<p>另一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> BlogController = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> index = <span class="function"><span class="keyword">function</span> (<span class="params">posts</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> Views.index(posts);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> show = <span class="function"><span class="keyword">function</span> (<span class="params">post</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> Views.show(post);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> create = <span class="function"><span class="keyword">function</span> (<span class="params">attrs</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> Db.create(attrs);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> update = <span class="function"><span class="keyword">function</span> (<span class="params">post, attrs</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> Db.update(post, attrs);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> destroy = <span class="function"><span class="keyword">function</span> (<span class="params">post</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> Db.destroy(post);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">index</span>: index, <span class="attr">show</span>: show, <span class="attr">create</span>: create, <span class="attr">update</span>: update, <span class="attr">destroy</span>: destroy &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>这个可笑的控制器（controller）99% 的代码都是垃圾。我们可以把它重写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> BlogController = &#123;<span class="attr">index</span>: Views.index, <span class="attr">show</span>: Views.show, crea</div><div class="line">te: Db.create, <span class="attr">update</span>: Db.update, <span class="attr">destroy</span>: Db.destroy&#125;;</div></pre></td></tr></table></figure>
<p>…或者直接全部删掉，因为它的作用仅仅就是把视图（Views）和数据库（Db）打包在一起而已。</p>
<p><strong>为何钟爱一等公民？</strong></p>
<p>两个例子你也都看到了，虽说添加一些没有实际用处的间接层实现起来很容易，但这样做除了徒增代码量，提高维护和检索代码的成本外，没有任何用处。<br>另外，如果一个函数被不必要地包裹起来了，而且发生了改动，那么包裹它的那个函数也要做相应的变更。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">httpGet(<span class="string">'/post/2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> renderPost(json);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果 httpGet 要改成可以抛出一个可能出现的 err 异常，那我们还要回过头去把“胶水”函数也改了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把整个应用里的所有 httpGet 调用都改成这样，可以传递 err 参数。</span></div><div class="line">httpGet(<span class="string">'/post/2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">json, err</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> renderPost(json, err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>写成一等公民函数的形式，要做的改动将会少得多：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">httpGet(<span class="string">'/post/2'</span>, renderPost); <span class="comment">// renderPost 将会在 httpGet 中调用，想要多少参数都行</span></div></pre></td></tr></table></figure>
<p><strong>纯函数的好处</strong></p>
<p>首先，我们要厘清纯函数的概念。</p>
<blockquote>
<p>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。</p>
</blockquote>
<p>比如 slice 和 splice ，相信很多人都用过。这两个函数的作用并无二致——但是注意，它们各自的方式却大不同，但不管怎么说作用还是一样的。我们说 slice 符合纯函数的定义是因为对相同的输入它保证能返回相同的输出。而 splice 却会嚼烂调用它的那个数组，然后再吐出来；这就会产生可观察到的副作用，即这个数组永久地改变了。</p>
<p>另一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不纯的</span></div><div class="line"><span class="keyword">var</span> minimum = <span class="number">21</span>;</div><div class="line"><span class="keyword">var</span> checkAge = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> age &gt;= minimum;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 纯的</span></div><div class="line"><span class="keyword">var</span> checkAge = <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> minimum = <span class="number">21</span>;</div><div class="line">	<span class="keyword">return</span> age &gt;= minimum;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在不纯的版本中， checkAge 的结果将取决于 minimum 这个可变变量的值。换句话说，它取决于系统状态；这一点令人沮丧，因为它引入了外部的环境.</p>
<blockquote>
<p>副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。</p>
<p>副作用可能包含，但不限于：更改文件系统，往数据库插入记录发送一个 http 请求可变数据，打印/log<br>，获取用户输入，DOM 查询，访问系统状态</p>
</blockquote>
<p>副作用让一个函数变得不纯是有道理的：从定义上来说，纯函数必须要能够根据相同的输入返回相同的输出；如果函数需要跟外部事物打交道，那么就无法保证这一点了。<br>我们来仔细了解下为何要坚持这种「相同输入得到相同输出」原则。</p>
<p><strong>八年级数学</strong></p>
<blockquote>
<p>函数是不同数值之间的特殊关系：每一个输入值返回且只返回一个输出值。</p>
</blockquote>
<p>换句话说，函数只是两种数值之间的关系：输入和输出。尽管每个输入都只会有一个输出，但不同的输入却可以有相同的输出。</p>
<p>如果输入直接指明了输出，那么就没有必要再实现具体的细节了。因为函数仅仅只是输入到输出的映射而已，所以从某种意义上来说，对象就是也是函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toLowerCase = &#123;<span class="string">"A"</span>:<span class="string">"a"</span>, <span class="string">"B"</span>: <span class="string">"b"</span>, <span class="string">"C"</span>: <span class="string">"c"</span>, <span class="string">"D"</span>: <span class="string">"d"</span>, <span class="string">"E"</span>: <span class="string">"e"</span>, <span class="string">"D"</span>: <span class="string">"d"</span>&#125;;</div><div class="line">toLowerCase[<span class="string">"C"</span>];</div><div class="line"><span class="comment">//=&gt; "c"</span></div><div class="line"><span class="keyword">var</span> isPrime = &#123;<span class="number">1</span>:<span class="literal">false</span>, <span class="number">2</span>: <span class="literal">true</span>, <span class="number">3</span>: <span class="literal">true</span>, <span class="number">4</span>: <span class="literal">false</span>, <span class="number">5</span>: <span class="literal">true</span>, <span class="number">6</span>:<span class="literal">false</span>&#125;;</div><div class="line">isPrime[<span class="number">3</span>];</div><div class="line"><span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure>
<p>纯函数就是数学上的函数，而且是函数式编程的全部。使用这些纯函数编程能够带来大量的好处，让我们来看一下为何要不遗余力地保留函数的纯粹性的原因。</p>
<p><strong>追求“纯”的理由</strong></p>
<ul>
<li>可缓存性（Cacheable）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> squareNumber = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x; &#125;);</div><div class="line">squareNumber(<span class="number">4</span>);</div><div class="line"><span class="comment">//=&gt; 16</span></div><div class="line">squareNumber(<span class="number">4</span>); <span class="comment">// 从缓存中读取输入值为 4 的结果</span></div><div class="line"><span class="comment">//=&gt; 16</span></div><div class="line">squareNumber(<span class="number">5</span>);</div><div class="line"><span class="comment">//=&gt; 25</span></div><div class="line">squareNumber(<span class="number">5</span>); <span class="comment">// 从缓存中读取输入值为 5 的结果</span></div><div class="line"><span class="comment">//=&gt; 25</span></div><div class="line"></div><div class="line"><span class="comment">//简单的memoize实现</span></div><div class="line"><span class="keyword">var</span> memoize = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cache = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> arg_str = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);</div><div class="line">        cache[arg_str] = cache[arg_str] || f.apply(f, <span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">return</span> cache[arg_str];</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在来看这种方式意义不大，不过很快我们就会学习一些技巧来发掘它的用处。重点是我们可以缓存任意一个函数，不管它们看起来多么具有破坏性。</p>
<ul>
<li>可移植性／自文档化</li>
</ul>
<p>纯函数是完全自给自足的，它需要的所有东西都能轻易获得。仔细思考思考这一点…这种自给自足的好处是什么呢？首先，纯函数的依赖很明确，因此更易于观察和理解——没有偷偷摸摸的小动作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不纯的</span></div><div class="line"><span class="keyword">var</span> signUp = <span class="function"><span class="keyword">function</span> (<span class="params">attrs</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> user = saveUser(attrs);</div><div class="line">    welcomeUser(user);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> saveUser = <span class="function"><span class="keyword">function</span> (<span class="params">attrs</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> user = Db.save(attrs);</div><div class="line">	...</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> welcomeUser = <span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</div><div class="line">    Email(user, ...);</div><div class="line">	...</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 纯的</span></div><div class="line"><span class="keyword">var</span> signUp = <span class="function"><span class="keyword">function</span> (<span class="params">Db, Email, attrs</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> user = saveUser(Db, attrs);</div><div class="line">        welcomeUser(Email, user);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> saveUser = <span class="function"><span class="keyword">function</span> (<span class="params">Db, attrs</span>) </span>&#123;</div><div class="line">	...</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> welcomeUser = <span class="function"><span class="keyword">function</span> (<span class="params">Email, user</span>) </span>&#123;</div><div class="line">	...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>纯函数对于其依赖必须要诚实，这样我们就能知道它的目的。仅从纯函数版本的 signUp 的签名就可以看出，它将要用到 Db 、 Email 和 attrs ，这在最小程度上给了我们足够多的信息。</p>
<ul>
<li>引用透明性</li>
</ul>
<p>很多人相信使用纯函数最大的好处是<strong>引用透明性（referential transparency）</strong>。如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。<br>由于纯函数总是能够根据相同的输入返回相同的输出，所以它们就能够保证总是返回同一个结果，这也就保证了引用透明性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Immutable = <span class="built_in">require</span>(<span class="string">'immutable'</span>);  <span class="comment">//一个库 使得数据是不变的。</span></div><div class="line"><span class="keyword">var</span> decrementHP = <span class="function"><span class="keyword">function</span> (<span class="params">player</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> player.set(<span class="string">"hp"</span>, player.hp - <span class="number">1</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> isSameTeam = <span class="function"><span class="keyword">function</span> (<span class="params">player1, player2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> player1.team === player2.team;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> punch = <span class="function"><span class="keyword">function</span> (<span class="params">player, target</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isSameTeam(player, target)) &#123;</div><div class="line">        <span class="keyword">return</span> target;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> decrementHP(target);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> jobe = Immutable.Map(</div><div class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jobe"</span>, <span class="attr">hp</span>: <span class="number">20</span>, <span class="attr">team</span>: <span class="string">"red"</span> &#125;</div><div class="line">);</div><div class="line"><span class="keyword">var</span> michael = Immutable.Map(&#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Michael"</span>, <span class="attr">hp</span>: <span class="number">20</span>, <span class="attr">team</span>: <span class="string">"green"</span></div><div class="line">&#125;);</div><div class="line">punch(jobe, michael);</div><div class="line"><span class="comment">//=&gt; Immutable.Map(&#123;name:"Michael", hp:19, team: "green"&#125;)</span></div></pre></td></tr></table></figure>
<p>decrementHP 、 isSameTeam 和 punch 都是纯函数，所以是引用透明的。我们可以使用一种叫做“<strong>等式推导”（equational reasoning）</strong>的技术来分析代码。所谓“等式推导”就是“一对一”替换</p>
<p>首先内联 isSameTeam 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> punch = <span class="function"><span class="keyword">function</span> (<span class="params">player, target</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (player.team === target.team) &#123;</div><div class="line">        <span class="keyword">return</span> target;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> decrementHP(target);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>因为是不可变数据，我们可以直接把 team 替换为实际值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> punch = <span class="function"><span class="keyword">function</span> (<span class="params">player, target</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="string">"red"</span> === <span class="string">"green"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> target;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> decrementHP(target);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>if 语句执行结果为 false ，所以可以把整个 if 语句都删掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> punch = <span class="function"><span class="keyword">function</span>(<span class="params">player, target</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> decrementHP(target);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果再内联 decrementHP ，我们会发现这种情况下， punch 变成了一个让 hp 的值减 1 的调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> punch = <span class="function"><span class="keyword">function</span>(<span class="params">player, target</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> target.set(<span class="string">"hp"</span>, target.hp<span class="number">-1</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>总之，等式推导带来的分析代码的能力对重构和理解代码非常重要。事实上，我们重构海鸥程序使用的正是这项技术：利用加和乘的特性。</p>
<h2 id="3-柯里化（curry）"><a href="#3-柯里化（curry）" class="headerlink" title="3.柯里化（curry）"></a>3.柯里化（curry）</h2><p>curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<p>我们先创建一些 curry 函数享受下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 回调式函数的currying,</span></div><div class="line"><span class="comment">// var curry = function (fn) &#123;</span></div><div class="line"><span class="comment">//     return function () &#123;</span></div><div class="line"><span class="comment">//         var args = Array.prototype.slice.call(arguments);</span></div><div class="line"><span class="comment">//         return function (callback) &#123;</span></div><div class="line"><span class="comment">//             args.push(callback);</span></div><div class="line"><span class="comment">//             return fn.apply(this, args);</span></div><div class="line"><span class="comment">//         &#125;</span></div><div class="line"><span class="comment">//     &#125;;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line"><span class="comment">//使用ramda库，来curry 函数，上面 curry 函数第一次是不能调用的。这里curry化的函数传进来两个参数是能调用的。可以说是高级版的。</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'ramda'</span>); </div><div class="line"><span class="keyword">var</span> match = _.curry(<span class="function"><span class="keyword">function</span> (<span class="params">what, str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.match(what);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//等价于</span></div><div class="line"><span class="comment">// var match = function(what,str)&#123;</span></div><div class="line"><span class="comment">//     if (arguments.length == 2 )&#123;</span></div><div class="line"><span class="comment">//         return str.match(what);</span></div><div class="line"><span class="comment">//     &#125;</span></div><div class="line"><span class="comment">//     return function(str)&#123;</span></div><div class="line"><span class="comment">//         return str.match(what);</span></div><div class="line"><span class="comment">//     &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> filter = _.curry(<span class="function"><span class="keyword">function</span> (<span class="params">f, ary</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> ary.filter(f);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//等价于</span></div><div class="line"><span class="comment">// var filter = function(f,ary)&#123;</span></div><div class="line"><span class="comment">//     if (arguments.length == 2 )&#123;</span></div><div class="line"><span class="comment">//         return ary.filter(f);</span></div><div class="line"><span class="comment">//     &#125;</span></div><div class="line"><span class="comment">//     return function(ary)&#123;</span></div><div class="line"><span class="comment">//         return ary.filter(f);</span></div><div class="line"><span class="comment">//     &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="keyword">var</span> replace = _.curry(<span class="function"><span class="keyword">function</span> (<span class="params">what, replacement, str</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> str.replace(what, replacement);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> map = _.curry(<span class="function"><span class="keyword">function</span> (<span class="params">f, ary</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> ary.map(f);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码中遵循的是一种简单，同时也非常重要的模式。即策略性地把要操作的数据（String， Array）放到最后一个参数里。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 下面match一下调用两个参数的情况一般不怎么常见，所以curry可以等价成上面那个函数。</div><div class="line">match(/\s+/g, "hello world");</div><div class="line">// [ ' ' ]</div><div class="line">match(/\s+/g)("hello world");</div><div class="line">// [ ' ' ]</div><div class="line">var hasSpaces = match(/\s+/g);</div><div class="line">// function(x) &#123; return x.match(/\s+/g) &#125;</div><div class="line">hasSpaces("hello world");</div><div class="line">// [ ' ' ]</div><div class="line">hasSpaces("spaceless");</div><div class="line">// null</div><div class="line">filter(hasSpaces, ["tori_spelling", "tori amos"]);</div><div class="line">// ["tori amos"]</div><div class="line">var findSpaces = filter(hasSpaces);</div><div class="line">// function(xs) &#123; return xs.filter(function(x) &#123; return x.match(</div><div class="line">/\s+/g) &#125;) &#125;</div><div class="line">findSpaces(["tori_spelling", "tori amos"]);</div><div class="line">// ["tori amos"]</div></pre></td></tr></table></figure>
<p>这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。</p>
<p>当我们谈论纯函数的时候，我们说它们接受一个输入返回一个输出。curry 函数所做的正是这样：每传递一个参数调用函数，就返回一个新函数处理剩余的参数。这就是一个输入对应一个输出啊。</p>
<p>哪怕输出是另一个函数，它也是纯函数。当然 curry 函数也允许一次传递多个参数，但这只是出于减少 () 的方便。</p>
<h2 id="4-代码组合（compose）"><a href="#4-代码组合（compose）" class="headerlink" title="4.代码组合（compose）"></a>4.代码组合（compose）</h2><p>这就是 组合 （compose，以下将称之为组合）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> compose = <span class="function"><span class="keyword">function</span> (<span class="params">f, g</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> f(g(x));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>f 和 g 都是函数， x 是在它们之间通过“管道”传输的值。组合 看起来像是在饲养函数。你就是饲养员，选择两个有特点又遭你喜欢的函数，让它们结合，产下一个崭新的函数。组合的用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x.toUpperCase(); &#125;;</div><div class="line"><span class="keyword">var</span> exclaim = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x + <span class="string">'!'</span>; &#125;;</div><div class="line"><span class="keyword">var</span> shout = compose(exclaim, toUpperCase);</div><div class="line">shout(<span class="string">"send in the clowns"</span>);</div><div class="line"><span class="comment">//=&gt; "SEND IN THE CLOWNS!"</span></div></pre></td></tr></table></figure>
<p>在 compose 的定义中， g 将先于 f 执行，因此就创建了一个从右到左的数据流。这样做的可读性远远高于嵌套一大堆的函数调用，如果不用组合， shout 函数将会是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shout = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> exclaim(toUpperCase(x));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>让代码从右向左运行，而不是由内而外运行，我觉得可以称之为“左倾”。</p>
<p>我们来创建一堆函数用来做测试。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toUpperCase = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x.toUpperCase(); &#125;;</div><div class="line"><span class="keyword">var</span> toLowerCase = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x.toLowerCase(); &#125;;</div><div class="line"><span class="keyword">var</span> toLower = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x.toLowerCase(); &#125;;</div><div class="line"><span class="keyword">var</span> exclaim = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x + <span class="string">'!'</span>; &#125;;</div><div class="line"><span class="keyword">var</span> head = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x[<span class="number">0</span>] &#125;;</div><div class="line"><span class="keyword">var</span> reduce = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123; <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123; <span class="keyword">return</span> arr.reduce(fn); &#125; &#125;</div><div class="line"><span class="keyword">var</span> reverse = reduce(<span class="function"><span class="keyword">function</span> (<span class="params">acc, x</span>) </span>&#123; <span class="keyword">return</span> [x].concat(acc); &#125;, []);</div></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> last = compose(head, reverse);</div><div class="line">last([<span class="string">'jumpkick'</span>, <span class="string">'roundhouse'</span>, <span class="string">'uppercut'</span>]);</div><div class="line"><span class="comment">//=&gt; 'uppercut'</span></div></pre></td></tr></table></figure>
<p>reverse 反转列表， head 取列表中的第一个元素；所以结果就是得到了一个last 函数（译者注：即取列表的最后一个元素），虽然它性能不高。这个组合中函数的执行顺序应该是显而易见的.</p>
<p>所有的组合都有的一个特性.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 结合律（associativity）</span></div><div class="line"><span class="keyword">var</span> associative = compose(f, compose(g, h)) == compose(compose(f, g), h);</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>这个特性就是结合律，符合结合律意味着不管你是把 g 和 h 分到一组，还是把f 和 g 分到一组都不重要。所以，如果我们想把字符串变为大写，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compose(toUpperCase, compose(head, reverse));</div><div class="line"><span class="comment">// 或者</span></div><div class="line">compose(compose(toUpperCase, head), reverse);</div></pre></td></tr></table></figure>
<p>因为如何为 compose 的调用分组不重要，所以结果都是一样的。这也让我们有能力写一个可变的组合（variadic compose），用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前面的例子中我们必须要写两个组合才行，但既然组合是符合结合律的，我们就可以只写一个，</span></div><div class="line"><span class="comment">// 而且想传给它多少个函数就传给它多少个，然后让它自己决定如何分组。</span></div><div class="line"><span class="keyword">var</span> lastUpper = _.compose(toUpperCase, head, reverse);</div><div class="line">lastUpper([<span class="string">'jumpkick'</span>, <span class="string">'roundhouse'</span>, <span class="string">'uppercut'</span>]);</div><div class="line"><span class="comment">//=&gt; 'UPPERCUT'</span></div><div class="line"><span class="keyword">var</span> loudLastUpper = _.compose(exclaim, toUpperCase, head, reverse)</div><div class="line">loudLastUpper([<span class="string">'jumpkick'</span>, <span class="string">'roundhouse'</span>, <span class="string">'uppercut'</span>]);</div><div class="line"><span class="comment">//=&gt; 'UPPERCUT!'</span></div></pre></td></tr></table></figure>
<p>结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。让我们来重构重构前面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> loudLastUpper = compose(exclaim, toUpperCase, head, reverse);</div><div class="line"><span class="comment">// 或</span></div><div class="line"><span class="keyword">var</span> last = compose(head, reverse);</div><div class="line"><span class="keyword">var</span> loudLastUpper = compose(exclaim, toUpperCase, last);</div><div class="line"><span class="comment">// 或</span></div><div class="line"><span class="keyword">var</span> last = compose(head, reverse);</div><div class="line"><span class="keyword">var</span> angry = compose(exclaim, toUpperCase);</div><div class="line"><span class="keyword">var</span> loudLastUpper = compose(angry, last);</div><div class="line"><span class="comment">// 更多变种...</span></div></pre></td></tr></table></figure>
<p><strong>pointfree</strong></p>
<p>pointfree 模式指的是，永远不必说出你的数据。</p>
<p>它的意思是说，函数无须提及将要操作的数据是什么样的。一等公民的函数、柯里化（curry）以及组合协作起来非常有助于实现这种模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非 pointfree，因为提到了数据：word</span></div><div class="line"><span class="keyword">var</span> snakeCase = <span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> word.toLowerCase().replace(<span class="regexp">/\s+/ig</span>, <span class="string">'_'</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// pointfree</span></div><div class="line"><span class="keyword">var</span> snakeCase = compose(replace(<span class="regexp">/\s+/ig</span>, <span class="string">'_'</span>), toLowerCase);</div></pre></td></tr></table></figure>
<p>看到 replace 是如何被局部调用的了么？这里所做的事情就是通过管道把数据在接受单个参数的函数间传递。利用 curry，我们能够做到让每个函数都先接收数据，然后操作数据，最后再把数据传递到下一个函数那里去。另外注意在 pointfree版本中，不需要 word 参数就能构造函数；而在非 pointfree 的版本中，必须要有word 才能进行进行一切操作。</p>
<p>我们再来看一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非 pointfree，因为提到了数据：name</span></div><div class="line"><span class="keyword">var</span> initials = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> name.split(<span class="string">' '</span>).map(compose(toUpperCase, head)).join(<span class="string">'.'</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// pointfree</span></div><div class="line"><span class="keyword">var</span> initials = compose(join(<span class="string">'. '</span>), map(compose(toUpperCase, head)), split(<span class="string">' '</span>));</div><div class="line">initials(<span class="string">"hunter stockton thompson"</span>);</div><div class="line"><span class="comment">// 'H. S. T'</span></div></pre></td></tr></table></figure>
<p>另外，pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。对函数式代码来说，pointfree 是非常好的石蕊试验，因为它能告诉我们一个函数是否是接受输入返回输出的小函数。</p>
<p><strong>debug</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> trace = curry(<span class="function"><span class="keyword">function</span>(<span class="params">tag, x</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(tag, x);</div><div class="line">	<span class="keyword">return</span> x;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>trace 函数允许我们在某个特定的点观察数据以便 debug。聪明的你肯定知道怎么用了。</p>
<p><strong>总结</strong><br>组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。</p>
<h2 id="5-实例"><a href="#5-实例" class="headerlink" title="5.实例"></a>5.实例</h2><p>声明式代码</p>
<p>声明式意味着我们要写表达式，而不是一步一步的指示。</p>
<p>我们写几个例子找找感觉。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 命令式</span></div><div class="line"><span class="keyword">var</span> makes = [];</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cars.length; i++) &#123;</div><div class="line">	makes.push(cars[i].make);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 声明式</span></div><div class="line"><span class="keyword">var</span> makes = cars.map(<span class="function"><span class="keyword">function</span>(<span class="params">car</span>)</span>&#123; <span class="keyword">return</span> car.make; &#125;);</div></pre></td></tr></table></figure>
<p>命令式的循环要求你必须先实例化一个数组，而且执行完这个实例化语句之后，解释器才继续执行后面的代码。然后再直接迭代 cars 列表，手动增加计数器，把各种零零散散的东西都展示出来…实在是直白得有些露骨。<br>使用 map 的版本是一个表达式，它对执行顺序没有要求。而且， map 函数如何进行迭代，返回的数组如何收集，都有很大的自由度。它指明的是 做什么 ，不是 怎么做 。因此，它是正儿八经的声明式代码。</p>
<p>再看一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 命令式</span></div><div class="line"><span class="keyword">var</span> authenticate = <span class="function"><span class="keyword">function</span>(<span class="params">form</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> user = toUser(form);</div><div class="line">	<span class="keyword">return</span> logIn(user);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 声明式</span></div><div class="line"><span class="keyword">var</span> authenticate = compose(logIn, toUser);</div></pre></td></tr></table></figure>
<p>虽然命令式的版本并不一定就是错的，但还是硬编码了那种一步接一步的执行方式。而 compose 表达式只是简单地指出了这样一个事实：用户验证是 toUser和 logIn 两个行为的组合。这再次说明，声明式为潜在的代码更新提供了支持，使得我们的应用代码成为了一种高级规范。</p>
<p>接下来我们做一个应用，功能是从 flickr 获取图片并在页面上展示。</p>
<ol>
<li>根据特定搜索关键字构造 url</li>
<li>向 flickr 发送 api 请求</li>
<li>把返回的 json 转为 html 图片</li>
<li>把图片放到网页渲染出来</li>
</ol>
<p>注意到没？上面提到了两个不纯的动作，即从 flickr 的 api 获取数据和在屏幕上放<br>置图片这两件事。我们先来定义这两个动作，这样就能隔离它们了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Impure = &#123;</div><div class="line">    <span class="attr">getJSON</span>: _.curry(<span class="function"><span class="keyword">function</span> (<span class="params">callback, url</span>) </span>&#123;</div><div class="line">        $.getJSON(url, callback);</div><div class="line">    &#125;),</div><div class="line">    <span class="attr">setHtml</span>: _.curry(<span class="function"><span class="keyword">function</span> (<span class="params">sel, html</span>) </span>&#123;</div><div class="line">        $(sel).html(html);</div><div class="line">    &#125;)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里只是简单地包装了一下 jQuery 的 getJSON 方法，把它变为一个 curry 函数，还有就是把参数位置也调换了下。这些方法都在 Impure 命名空间下，这样我们就知道它们都是危险函数。在后面的例子中，我们会把这两个函数变纯。</p>
<p>下一步是构造 url 传给 Impure.getJSON 函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="function"><span class="keyword">function</span> (<span class="params">term</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">'https://api.flickr.com/services/feeds/photos_public.gne?tags='</span> + term + <span class="string">'&amp;format=json&amp;jsoncallback=?'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>借助 monoid 或 combinator （后面会讲到这些概念），我们可以使用一些奇技淫巧来让 url 函数变为 pointfree 函数。但是为了可读性，我们还是选择以普通的非pointfree 的方式拼接字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = _.compose(Impure.getJSON(trace(<span class="string">"response"</span>)), url);</div><div class="line">app(<span class="string">"cats"</span>);</div></pre></td></tr></table></figure>
<p>这会调用 url 函数，然后把字符串传给 getJSON 函数。 getJSON 已经局部应用了 trace(这个是我们事先写好的，等下要替代的) ，加载这个应用将会把请求的响应显示在 console 里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取的json数据大概比方说是这样的。</span></div><div class="line">items:[</div><div class="line">  &#123;</div><div class="line">    <span class="string">"media"</span>:&#123;</div><div class="line">      <span class="string">"m"</span>:<span class="string">"xxxx.jpg"</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">   &#123;</div><div class="line">    <span class="string">"media"</span>:&#123;</div><div class="line">      <span class="string">"m"</span>:<span class="string">"yyy.jpg"</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">]</div></pre></td></tr></table></figure>
<p>我们想要从这个 json 里构造图片，看起来 src 都在 items 数组中的每个media 对象的 m 属性上。<br>不管怎样，我们可以使用 ramda 的一个通用 getter 函数 _.prop() 来获取这些嵌套的属性。不过为了让你明白这个函数做了什么事情，我们自己实现一个 prop 看看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> prop = _.curry(<span class="function"><span class="keyword">function</span>(<span class="params">property, object</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> object[property];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mediaUrl = _.compose(_.prop(<span class="string">'m'</span>), _.prop(<span class="string">'media'</span>));</div><div class="line"><span class="keyword">var</span> srcs = _.compose(_.map(mediaUrl), _.prop(<span class="string">'items'</span>));</div></pre></td></tr></table></figure>
<p>一旦得到了 items ，就必须使用 map 来分解每一个 url；这样就得到了一个包含所有 src 的数组。把它和 app 联结起来，打印结果看看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> renderImages = _.compose(Impure.setHtml(<span class="string">"body"</span>), srcs);</div><div class="line"><span class="keyword">var</span> app = _.compose(Impure.getJSON(renderImages), url);</div></pre></td></tr></table></figure>
<p>这里所做的只不过是新建了一个组合，这个组合会调用 srcs 函数，并把返回结果设置为 body 的 html。我们也把 trace 替换为了 renderImages ，因为已经有了除原始 json 以外的数据。这将会粗暴地把所有的 src 直接显示在屏幕上。</p>
<p>最后一步是把这些 src 变为真正的图片。对大型点的应用来说，是应该使用类似Handlebars 或者 React 这样的 template/dom 库来做这件事的。但我们这个应用太小了，只需要一个 img 标签，所以用 jQuery 就好了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> $(<span class="string">'&lt;img /&gt;'</span>, &#123; <span class="attr">src</span>: url &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>jQuery 的 html() 方法接受标签数组为参数，所以我们只须把 src 转换为 img 标签然后传给 setHtml 即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> images = _.compose(_.map(img), srcs);</div><div class="line"><span class="keyword">var</span> renderImages = _.compose(Impure.setHtml(<span class="string">"body"</span>), images);</div><div class="line"><span class="keyword">var</span> app = _.compose(Impure.getJSON(renderImages), url);</div></pre></td></tr></table></figure>
<p>任务完成！ 看不懂，没关系，下面是完整代码和分析图，看完分分钟搞定。</p>
<p>完整代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> $(<span class="string">'&lt;img /&gt;'</span>, &#123; <span class="attr">src</span>: url &#125;);</div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> <span class="keyword">var</span> Impure = &#123;</div><div class="line">   <span class="attr">getJSON</span>: _.curry(<span class="function"><span class="keyword">function</span>(<span class="params">callback, url</span>) </span>&#123;</div><div class="line">     $.getJSON(url, callback)</div><div class="line">   &#125;),</div><div class="line"></div><div class="line">   <span class="attr">setHtml</span>: _.curry(<span class="function"><span class="keyword">function</span>(<span class="params">sel, html</span>) </span>&#123;</div><div class="line">     $(sel).html(html)</div><div class="line">   &#125;)</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">var</span> trace = _.curry(<span class="function"><span class="keyword">function</span>(<span class="params">tag, x</span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(tag, x);</div><div class="line">     <span class="keyword">return</span> x;</div><div class="line"> &#125;)</div><div class="line"></div><div class="line"> <span class="comment">////////////////////////////////////////////</span></div><div class="line"> <span class="comment">//  url :: String -&gt; URL</span></div><div class="line"> <span class="keyword">var</span> url = <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">'https://api.flickr.com/services/feeds/photos_public.gne?tags='</span> + t + <span class="string">'&amp;format=json&amp;jsoncallback=?'</span>;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> <span class="keyword">var</span> mediaUrl = _.compose(_.prop(<span class="string">'m'</span>), _.prop(<span class="string">'media'</span>));</div><div class="line"> <span class="keyword">var</span> srcs = _.compose(_.map(mediaUrl), _.prop(<span class="string">'items'</span>));</div><div class="line"> <span class="keyword">var</span> images = _.compose(_.map(img), srcs);</div><div class="line"> <span class="comment">////////////////////////////////////////////</span></div><div class="line"> <span class="comment">// Impure</span></div><div class="line"> <span class="keyword">var</span> renderImages = _.compose(Impure.setHtml(<span class="string">"body"</span>), images)</div><div class="line"> <span class="keyword">var</span> app = _.compose(Impure.getJSON(renderImages), url)</div><div class="line"></div><div class="line"> app(<span class="string">"cats"</span>)</div></pre></td></tr></table></figure>
<p>还看不懂？没关系，我们画个图</p>
<p><img src="/img/fp/fp.png" alt="fp"></p>
<p>可以看到这个管道是怎么流通的.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url ---&gt; items ---&gt; map( media ---&gt; m) ---&gt; map( img ) ---&gt; setHtml</div></pre></td></tr></table></figure>
<p>第一个看可能看不懂，你可以暂停一下。多看几次。</p>
<p>多看几次。。。，</p>
<p>多看几次。。。。</p>
<p>然后你就感觉我操。。厉害了我的函数式。。。</p>
<p>最后我们来利用简单的数学定律以及上面介绍过的等式推导，重构一下。</p>
<p>我们获取 url map 了一次，把这些 url 变为 img 标签又 map 了一次。关于 map 和组合是有定律的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// map 的组合律</span></div><div class="line"><span class="keyword">var</span> law = compose(map(f), map(g)) == map(compose(f, g));</div></pre></td></tr></table></figure>
<p>我们可以利用这个定律优化代码，进行一次有原则的重构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原有代码</span></div><div class="line"><span class="keyword">var</span> mediaUrl = _.compose(_.prop(<span class="string">'m'</span>), _.prop(<span class="string">'media'</span>));</div><div class="line"><span class="keyword">var</span> srcs = _.compose(_.map(mediaUrl), _.prop(<span class="string">'items'</span>));</div><div class="line"><span class="keyword">var</span> images = _.compose(_.map(img), srcs);</div></pre></td></tr></table></figure>
<p>感谢等式推导（equational reasoning）及纯函数的特性，我们可以内联调用srcs 和 images ，也就是把 map 调用排列起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mediaUrl = _.compose(_.prop(<span class="string">'m'</span>), _.prop(<span class="string">'media'</span>));</div><div class="line"><span class="keyword">var</span> images = _.compose(_.map(img), _.map(mediaUrl), _.prop(<span class="string">'items'</span>));</div></pre></td></tr></table></figure>
<p>把 map 排成一列之后就可以应用组合律了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mediaUrl = _.compose(_.prop(<span class="string">'m'</span>), _.prop(<span class="string">'media'</span>));</div><div class="line"><span class="keyword">var</span> images = _.compose(_.map(_.compose(img, mediaUrl)), _.prop(<span class="string">'items'</span>));</div></pre></td></tr></table></figure>
<p>现在只需要循环一次就可以把每一个对象都转为 img 标签了。我们把 map 调用的compose 取出来放到外面，提高一下可读性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mediaUrl = _.compose(_.prop(<span class="string">'m'</span>), _.prop(<span class="string">'media'</span>));</div><div class="line"><span class="keyword">var</span> mediaToImg = _.compose(img, mediaUrl);</div><div class="line"><span class="keyword">var</span> images = _.compose(_.map(mediaToImg), _.prop(<span class="string">'items'</span>));</div></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>我们已经见识到如何在一个小而不失真实的应用中运用新技能了，也已经使用过函数式这个“数学框架”来推导和重构代码了。</p>
<p>但是很重要的几点还没说，就是我们这是js语言，异常处理还没做以及最最重要的异步处理。。。。</p>
<h2 id="6-类型签名"><a href="#6-类型签名" class="headerlink" title="6.类型签名"></a>6.类型签名</h2><h2 id="7-异常和异步处理"><a href="#7-异常和异步处理" class="headerlink" title="7.异常和异步处理"></a>7.异常和异步处理</h2><p>抄袭:</p>
<p><a href="">函数式编程</a></p>
<p><a href="">函数式编程指南</a></p>
</div>

    <div class="post-sidebar">
  <div class="toggle-btn" id="toggle-btn">
    <i class="fa fa-reorder"></i>
  </div>
  <section class="post-toc-wrap" id="post-sidebar">
    <h2 class="toc-title">内容目录</h2>
    <div class="post-toc">
      
      
        <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-简介"><span class="nav-number">1.</span> <span class="nav-text">一.简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-一个简单例子的开始"><span class="nav-number">2.</span> <span class="nav-text">二.一个简单例子的开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-函数第一等公民和纯函数的好处"><span class="nav-number">3.</span> <span class="nav-text">二.函数第一等公民和纯函数的好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-柯里化（curry）"><span class="nav-number">4.</span> <span class="nav-text">3.柯里化（curry）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-代码组合（compose）"><span class="nav-number">5.</span> <span class="nav-text">4.代码组合（compose）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-实例"><span class="nav-number">6.</span> <span class="nav-text">5.实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-类型签名"><span class="nav-number">7.</span> <span class="nav-text">6.类型签名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-异常和异步处理"><span class="nav-number">8.</span> <span class="nav-text">7.异常和异步处理</span></a></li></ol></div>
      
    </div>
  </section>
</div>


  </div>

  <footer class="post-footer">
    
      <div class="post-tags">
        
          <a href="/tags#JavaScript" rel="tag">#JavaScript</a>
        
      </div>
    
    

  </footer>

</article>




      
  <div class="comments" id="comments">
    
  </div>




    </main>

    <footer class="footer clearfix">
  <div class="copyright" >
    <span>Copyright</span>
    
    &copy; 
    <span itemprop="copyrightYear">2017</span>
    <span class="author" itemprop="copyrightHolder">ChenXing</span>
  </div>

  <div class="info">
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <span id="busuanzi_container_site_pv">
        总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
  </div>

</footer>


  </div>

  <div class="back-top-btn" id="back-top-btn"><i class="fa fa-chevron-up"></i></div>






  





<script type="text/javascript" src="/js/motto.min.js?v=0.4.5.1"></script>
<script type="text/javascript" src="/js/main.js?v=0.4.5.1"></script>


</body>
</html>
