<!DOCTYPE html>
<html lang="en">
<head>
  <!-- content-Type -->
<meta charset="utf-8">


<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="renderer" content="webkit|ie-comp|ie-stand">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="language" content="en">
<meta name="robots" content="all">


<meta content="yes" name="apple-mobile-web-app-capable">
<meta content="black" name="apple-mobile-web-app-status-bar-style">
<meta content="telephone=no" name="format-detection">
<meta content="email=no" name="format-detection">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






<meta name="google-site-verification" content="xxxxxxxxxx" />




<meta name="baidu-site-verification" content="xxxxxxxxxx" />







<meta name="keywords" content="Node," />


<meta name="description" content="[TOC]
在分析events源码之前，我们来看看js设计模式中的发布 — 订阅模式。
发布—订阅模式发布 — 订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript开发中，我们一般用事件模型来替代传统的发布 — 订阅模式。
如何一步步实现发布 — 订阅模式？

首先要指定好谁充当发布者
然后给发布者添加一个">
<meta property="og:type" content="article">
<meta property="og:title" content="Nodejs源码解析之events">
<meta property="og:url" content="http://yoursite.com/2016/11/20/Nodejs源码解析之events/index.html">
<meta property="og:site_name" content="ChenXing">
<meta property="og:description" content="[TOC]
在分析events源码之前，我们来看看js设计模式中的发布 — 订阅模式。
发布—订阅模式发布 — 订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript开发中，我们一般用事件模型来替代传统的发布 — 订阅模式。
如何一步步实现发布 — 订阅模式？

首先要指定好谁充当发布者
然后给发布者添加一个">
<meta property="og:updated_time" content="2017-03-02T13:05:57.316Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nodejs源码解析之events">
<meta name="twitter:description" content="[TOC]
在分析events源码之前，我们来看看js设计模式中的发布 — 订阅模式。
发布—订阅模式发布 — 订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript开发中，我们一般用事件模型来替代传统的发布 — 订阅模式。
如何一步步实现发布 — 订阅模式？

首先要指定好谁充当发布者
然后给发布者添加一个">






  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />






<link href="http://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


<script>
(function(){
  var bp = document.createElement('script');
  bp.src = '//push.zhanzhang.baidu.com/push.js';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script>

  <title> Nodejs源码解析之events </title>
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'xxxxxxxxxx', 'auto');
  ga('send', 'pageview');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?1551fdd18711ccb1c048bb11f579b1a4";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



</head>
<body lang="zh-Hans">

  <!--[if lte IE 9]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->


  <div class="another-theme layout">

    
<header class="header" id="header">

  <div class="header-cont">
    <div class="text-area">
      
        <h1 class="title" data-text="Nodejs源码解析之events"> Nodejs源码解析之events </h1>

        
        <div class="post-meta">
          <div class="post-time">
            发表于
            <time  datetime="2016-11-20T20:53:53+08:00" content="2016-11-20">
              2016-11-20
            </time>
          </div>

          
            <div class="post-category" >
              
                <span>
                  <a href="/categories#Node" itemprop="url" rel="index">
                    <span itemprop="name">Node</span>
                  </a>
                </span>

                
                

              
            </div>
          

          
            
              <span class="post-comments-count">
                <a href="/2016/11/20/Nodejs源码解析之events/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/20/Nodejs源码解析之events/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          
        </div>
        
      
    </div>
    <!-- Navigation -->
    
    <nav class="navigation clearfix" id="navigation">
      
        
        <a class="nav-link" href="/" rel="section">
          首页
        </a>
      
        
        <a class="nav-link" href="/tags" rel="section">
          标签
        </a>
      
        
        <a class="nav-link" href="/categories" rel="section">
          分类
        </a>
      
        
        <a class="nav-link" href="/about" rel="section">
          关于
        </a>
      
    </nav>
    
  </div>
  <div class="mask"></div>
</header>


    <main class="container">

      

  <article class="post-article post-type-normal post" itemscope>

  <div class="post-body">

    <div class="content markdown-body"><p>[TOC]</p>
<p>在分析events源码之前，我们来看看js设计模式中的发布 — 订阅模式。</p>
<h2 id="发布—订阅模式"><a href="#发布—订阅模式" class="headerlink" title="发布—订阅模式"></a>发布—订阅模式</h2><p>发布 — 订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状<br>态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript开发中，我们一般用事件模型<br>来替代传统的发布 — 订阅模式。</p>
<p>如何一步步实现发布 — 订阅模式？</p>
<ol>
<li>首先要指定好谁充当发布者</li>
<li>然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者</li>
<li>最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函<br>数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Event = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> clientList = &#123;&#125;, <span class="comment">//缓存列表</span></div><div class="line">		listen,	<span class="comment">// 增加订阅者</span></div><div class="line">		trigger, <span class="comment">//发布者</span></div><div class="line">		remove; <span class="comment">//取消订阅</span></div><div class="line">	listen = <span class="function"><span class="keyword">function</span>(<span class="params"> key, fn </span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span> ( !clientList[ key ] )&#123;   <span class="comment">// 如果还没有订阅过此类消息，给该类消息创建一个缓存列表</span></div><div class="line">			clientList[ key ] = [];</div><div class="line">		&#125;</div><div class="line">		clientList[ key ].push( fn );<span class="comment">// 订阅的消息添加进消息缓存列表</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">// 发布消息</span></div><div class="line">		<span class="keyword">var</span> key = <span class="built_in">Array</span>.prototype.shift.call( <span class="built_in">arguments</span> );	 <span class="comment">// 取出消息类型</span></div><div class="line">			fns = clientList[ key ];	<span class="comment">// 取出该消息对应的回调函数集合</span></div><div class="line">			<span class="keyword">if</span> ( !fns || fns.length === <span class="number">0</span> )&#123;  <span class="comment">// 如果没有订阅该消息，则返回</span></div><div class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = fns[ i++ ]; )&#123;</div><div class="line">				fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); <span class="comment">// arguments 是发布消息时附送的参数</span></div><div class="line">			&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	remove = <span class="function"><span class="keyword">function</span>(<span class="params"> key, fn </span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> fns = clientList[ key ];</div><div class="line">		<span class="keyword">if</span> ( !fns )&#123;   <span class="comment">// 如果 key 对应的消息没有被人订阅，则直接返回</span></div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> ( !fn )&#123;  <span class="comment">// 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅</span></div><div class="line">			fns &amp;&amp; ( fns.length = <span class="number">0</span> );</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">for</span> ( <span class="keyword">var</span> l = fns.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l-- )&#123;  <span class="comment">// 反向遍历订阅的回调函数列表</span></div><div class="line">				<span class="keyword">var</span> _fn = fns[ l ];</div><div class="line">				<span class="keyword">if</span> ( _fn === fn )&#123;</div><div class="line">					fns.splice( l, <span class="number">1</span> );   <span class="comment">// 删除订阅者的回调函数</span></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">listen</span> : listen,</div><div class="line">		<span class="attr">trigger</span>: trigger,</div><div class="line">		<span class="attr">remove</span> : remove</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;)();</div><div class="line"></div><div class="line">Event.listen( <span class="string">'squareMeter88'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> price </span>)</span>&#123; <span class="comment">// 小红订阅消息</span></div><div class="line">	<span class="built_in">console</span>.log( <span class="string">'价格= '</span> + price ); <span class="comment">// 输出：'价格=2000000'</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//Event.remove('squareMeter88');</span></div><div class="line">Event.trigger( <span class="string">'squareMeter88'</span>, <span class="number">2000000</span> ); <span class="comment">// 售楼处发布消息</span></div></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>Nodejs中的events模块是很常见的模块，其实现了事件注册，通知等功能，是观察者模式的实现。其使用很简单，实例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 导入events模块</span></div><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="comment">// 创建EventEmitter对象</span></div><div class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</div><div class="line"></div><div class="line"><span class="comment">//回调函数1</span></div><div class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'listener1 executed.'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数2</span></div><div class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'listener2 executed.'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 注册事件的回调函数， 相当于增加观察者</span></div><div class="line">eventEmitter.addListener(<span class="string">'connection'</span>, listener1);</div><div class="line"></div><div class="line"><span class="comment">// 再次注册同样事件的回调函数， 相当于增加观察者</span></div><div class="line">eventEmitter.on(<span class="string">'connection'</span>, listener2);</div><div class="line"></div><div class="line"><span class="comment">// 触发事件，这个时候，会有函数 listener1 和listener2同时被调用</span></div><div class="line">eventEmitter.emit(<span class="string">'connection'</span>);</div></pre></td></tr></table></figure>
<p>上述代码使用是相当简单的，这个是如何实现的的呢？ 其实这个是一般观察者的设计模式的实现逻辑是类似的，都是有一个缓存列表，存储监听事件和回调函数的对应关系，当监听事件发生时，调用回调函数，这个也不例外。不多说，来看源代码吧。</p>
<p><strong>初始化</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//这个就是用于调用Init函数,</span></div><div class="line">  EventEmitter.init.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 导出函数，这个就是一个events模块的总体导出函数</span></div><div class="line"><span class="comment">// 在上述的用法中，我们都是需要创建一个EventEmitter对象的</span></div><div class="line"><span class="built_in">module</span>.exports = EventEmitter;</div><div class="line"></div><div class="line"><span class="comment">// 用于兼容node 0.10.x</span></div><div class="line">EventEmitter.EventEmitter = EventEmitter;</div><div class="line"><span class="comment">// 是否使用domain，默认用法是不使用。Domain其实是EventEmitter子类，</span></div><div class="line"><span class="comment">// 一个单独的模块，这里不进一步分析，有兴趣可以看domain.js</span></div><div class="line">EventEmitter.usingDomains = <span class="literal">false</span>;</div><div class="line"><span class="comment">// 同上，用于domain模块</span></div><div class="line">EventEmitter.prototype.domain = <span class="literal">undefined</span>;</div><div class="line"><span class="comment">// 这个就是用于存储事件和回调的类map对象</span></div><div class="line">EventEmitter.prototype._events = <span class="literal">undefined</span>;</div><div class="line"><span class="comment">// </span></div><div class="line">EventEmitter.prototype._maxListeners = <span class="literal">undefined</span>;</div><div class="line"></div><div class="line"><span class="comment">// By default EventEmitters will print a warning if more than 10 listeners // are added to it. This is a useful default which helps finding memory leaks.</span></div><div class="line"><span class="comment">// 默认的最大的观察者的个数，默认为10， 如果超过，会有警告信息，以避免内存泄漏</span></div><div class="line">EventEmitter.defaultMaxListeners = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">// 初始化，构造函数必须调用的部分</span></div><div class="line">EventEmitter.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 下面是对domain的处理，不考虑</span></div><div class="line">  <span class="keyword">this</span>.domain = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">if</span> (EventEmitter.usingDomains) &#123;</div><div class="line">    <span class="comment">// if there is an active domain, then attach to it.</span></div><div class="line">    domain = domain || <span class="built_in">require</span>(<span class="string">'domain'</span>);</div><div class="line">    <span class="keyword">if</span> (domain.active &amp;&amp; !(<span class="keyword">this</span> <span class="keyword">instanceof</span> domain.Domain)) &#123;</div><div class="line">      <span class="keyword">this</span>.domain = domain.active;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">   <span class="comment">// 创建了一个_events 的空对象，相当于创建了一个map</span></div><div class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>._events || <span class="keyword">this</span>._events === <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>)._events)</div><div class="line">    <span class="keyword">this</span>._events = &#123;&#125;;</div><div class="line">  <span class="comment">// 用于保存当前最大监听数目，后面会用到</span></div><div class="line">  <span class="keyword">this</span>._maxListeners = <span class="keyword">this</span>._maxListeners || <span class="literal">undefined</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过上述的源码分析，可以得出，当我们创建<code>EventEmitter对象</code>时候，其实就是生成了一个<code>_events的空对象</code>，做一些基本的检查。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 导入events模块</span></div><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="comment">// 创建EventEmitter对象</span></div><div class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</div><div class="line"><span class="comment">//也可以直接 new events();</span></div></pre></td></tr></table></figure>
<p><strong>增/删 监听</strong></p>
<p>首先来查看一下增加监听相关的源代码，这里有三个函数：</p>
<ul>
<li>addListener: 增加事件监听。</li>
<li>on： addListener的别名，实际上是一样的。</li>
<li>once： 增加事件监听，不同的是，事件被fire一次后，会掉函数不再被执行。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> <span class="title">addListener</span>(<span class="params">type, listener</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> m;</div><div class="line">   <span class="comment">// 首先查看的是否listener为一个函数，确保是可以被执行的会掉函数</span></div><div class="line">  <span class="keyword">if</span> (!util.isFunction(listener))</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'listener must be a function'</span>);</div><div class="line"></div><div class="line">  <span class="comment">//确保_events对象已经被创建</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events)</div><div class="line">    <span class="keyword">this</span>._events = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="comment">// To avoid recursion in the case that type === "newListener"! Before</span></div><div class="line">  <span class="comment">// adding it to the listeners, first emit "newListener".</span></div><div class="line">  <span class="comment">// 从注释上，这个是防止递归调用的，这里只有定义了newListener后，才会发送事件</span></div><div class="line">  <span class="comment">// newListener，从本函数的代码，可以看出，newListener没有被定义，可以忽视</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._events.newListener)</div><div class="line">    <span class="keyword">this</span>.emit(<span class="string">'newListener'</span>, type,</div><div class="line">              util.isFunction(listener.listener) ?</div><div class="line">              listener.listener : listener);</div><div class="line">  <span class="comment">// 查看该type（事件）是否存在，</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events[type])</div><div class="line">    <span class="comment">// Optimize the case of one listener. Don't need the extra array object.</span></div><div class="line">    <span class="comment">// 如果不存在，直接存入就可以</span></div><div class="line">    <span class="keyword">this</span>._events[type] = listener;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (util.isObject(<span class="keyword">this</span>._events[type]))</div><div class="line">    <span class="comment">// If we've already got an array, just append.</span></div><div class="line">     <span class="comment">// 如果存在，并且是array，直接push</span></div><div class="line">    <span class="keyword">this</span>._events[type].push(listener);</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="comment">// Adding the second element, need to change to array.</span></div><div class="line">    <span class="comment">// 如果不是array，生成一个新的array</span></div><div class="line">    <span class="keyword">this</span>._events[type] = [<span class="keyword">this</span>._events[type], listener];</div><div class="line"></div><div class="line">  <span class="comment">// Check for listener leak</span></div><div class="line">  <span class="comment">// 下面的代码就是查看是否监听者超过了最大的数目，这个是关于默认的数目的</span></div><div class="line">  <span class="keyword">if</span> (util.isObject(<span class="keyword">this</span>._events[type]) &amp;&amp; !<span class="keyword">this</span>._events[type].warned) &#123;</div><div class="line">    <span class="keyword">var</span> m;</div><div class="line">    <span class="keyword">if</span> (!util.isUndefined(<span class="keyword">this</span>._maxListeners)) &#123;</div><div class="line">      m = <span class="keyword">this</span>._maxListeners;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      m = EventEmitter.defaultMaxListeners;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">//如果数目过大，直接给出console.error</span></div><div class="line">    <span class="keyword">if</span> (m &amp;&amp; m &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>._events[type].length &gt; m) &#123;</div><div class="line">      <span class="keyword">this</span>._events[type].warned = <span class="literal">true</span>;</div><div class="line">      <span class="built_in">console</span>.error(<span class="string">'(node) warning: possible EventEmitter memory '</span> +</div><div class="line">                    <span class="string">'leak detected. %d %s listeners added. '</span> +</div><div class="line">                    <span class="string">'Use emitter.setMaxListeners() to increase limit.'</span>,</div><div class="line">                    <span class="keyword">this</span>._events[type].length, type);</div><div class="line">      <span class="built_in">console</span>.trace();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 这里就是说on 和addListener是相互一样的，别名。</span></div><div class="line">EventEmitter.prototype.on = EventEmitter.prototype.addListener;</div><div class="line"><span class="comment">// 查看once，事件触发一次回调函数，就删除，相当于调用了removeListener</span></div><div class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">type, listener</span>) </span>&#123;</div><div class="line">  <span class="comment">// 依然一样是确保参数为函数，可以回调</span></div><div class="line">  <span class="keyword">if</span> (!util.isFunction(listener))</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'listener must be a function'</span>);</div><div class="line">  <span class="comment">// 回调函数是否被fire了 </span></div><div class="line">  <span class="keyword">var</span> fired = <span class="literal">false</span>;</div><div class="line">  <span class="comment">// 帮助函数</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 删除回调函数，请注意，一旦被fired掉，就删除</span></div><div class="line">    <span class="keyword">this</span>.removeListener(type, g);</div><div class="line">    <span class="comment">// 检查是否被fired过了，我想，这个可能是防止重复增加的case，也就是多次调用了once的  情况</span></div><div class="line">    <span class="keyword">if</span> (!fired) &#123;</div><div class="line">      fired = <span class="literal">true</span>;</div><div class="line">      <span class="comment">// 执行回调函数</span></div><div class="line">      listener.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 增加一个listener属性为回调函数</span></div><div class="line">  g.listener = listener;</div><div class="line">  <span class="comment">// 增加具体的回调函数，该回调函数变成了帮助函数g，而不是listener</span></div><div class="line">  <span class="keyword">this</span>.on(type, g);</div><div class="line">  <span class="comment">// 返回整个对象</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下面介绍一下删除回调相关的函数。</p>
<ul>
<li>removeListener - 删除具体的事件回调</li>
<li>removeAllListeners - 删除具体时间相关的所有的回调</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">EventEmitter.prototype.removeListener =</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeListener</span>(<span class="params">type, listener</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> list, position, length, i;</div><div class="line"></div><div class="line">  <span class="comment">//依然是检查listener是否为函数</span></div><div class="line">  <span class="keyword">if</span> (!util.isFunction(listener))</div><div class="line">    <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'listener must be a function'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 确保_events是否为空，以及事件存在在对象中</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events || !<span class="keyword">this</span>._events[type])</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  <span class="comment">// 等到回调函数的value</span></div><div class="line">  list = <span class="keyword">this</span>._events[type];</div><div class="line">  length = list.length;</div><div class="line">  position = <span class="number">-1</span>;</div><div class="line">  <span class="comment">// 如果当前的value和要删除的回调是相等的，包含once的内容</span></div><div class="line">  <span class="keyword">if</span> (list === listener ||</div><div class="line">      (util.isFunction(list.listener) &amp;&amp; list.listener === listener)) &#123;</div><div class="line">    <span class="comment">// 直接删除</span></div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>._events[type];</div><div class="line">    <span class="comment">// 发送事件</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._events.removeListener)</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, listener);</div><div class="line">  &#125; <span class="comment">// 如果是队列，直接出来</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (util.isObject(list)) &#123;</div><div class="line">    <span class="keyword">for</span> (i = length; i-- &gt; <span class="number">0</span>;) &#123;</div><div class="line">      <span class="keyword">if</span> (list[i] === listener ||</div><div class="line">          (list[i].listener &amp;&amp; list[i].listener === listener)) &#123;</div><div class="line">        position = i;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">// 如果查找不到，直接返回</span></div><div class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">     <span class="comment">// 如果长度为1，说明可以删除</span></div><div class="line">    <span class="keyword">if</span> (list.length === <span class="number">1</span>) &#123;</div><div class="line">      list.length = <span class="number">0</span>;</div><div class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>._events[type];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// 直接在数组中删除该回调</span></div><div class="line">      list.splice(position, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">     <span class="comment">// fire removeListener事件</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._events.removeListener)</div><div class="line">      <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, listener);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 删除与单一事件相关的所有回调函数</span></div><div class="line">EventEmitter.prototype.removeAllListeners =</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeAllListeners</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> key, listeners;</div><div class="line"> <span class="comment">// 确保_events不为空</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  <span class="comment">// not listening for removeListener, no need to emit</span></div><div class="line">  <span class="comment">// 查看当前是否有removeListener的监听者，从本模块看，没有赋值，所以一般情况下，都是</span></div><div class="line">  <span class="comment">// 直接删除回调然后返回</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events.removeListener) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>)</div><div class="line">      <span class="keyword">this</span>._events = &#123;&#125;;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._events[type])</div><div class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>._events[type];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// emit removeListener for all listeners on all events</span></div><div class="line">  <span class="comment">// 处理没有参数的情况，在没有参数的情况下，就是删除所有事件的回调</span></div><div class="line">  <span class="comment">// 相当于清空。 </span></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> <span class="keyword">this</span>._events) &#123;</div><div class="line">      <span class="comment">// 注意有特殊情况是，不删除removeListener的回调</span></div><div class="line">      <span class="keyword">if</span> (key === <span class="string">'removeListener'</span>) <span class="keyword">continue</span>;</div><div class="line">      <span class="keyword">this</span>.removeAllListeners(key);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.removeAllListeners(<span class="string">'removeListener'</span>);</div><div class="line">    <span class="keyword">this</span>._events = &#123;&#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 处理有具体参数的情况， 找到具体回调函数</span></div><div class="line">  listeners = <span class="keyword">this</span>._events[type];</div><div class="line"></div><div class="line">  <span class="comment">// 如果回调是单个函数，直接删除就好</span></div><div class="line">  <span class="keyword">if</span> (util.isFunction(listeners)) &#123;</div><div class="line">    <span class="keyword">this</span>.removeListener(type, listeners);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(listeners)) &#123;</div><div class="line">    <span class="comment">// LIFO order</span></div><div class="line">    <span class="comment">// 处理回调函数是一个数组的情况，从后往前一个一个删除。</span></div><div class="line">    <span class="keyword">while</span> (listeners.length)</div><div class="line">      <span class="keyword">this</span>.removeListener(type, listeners[listeners.length - <span class="number">1</span>]);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 清空事件对于的回调函数对象</span></div><div class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>._events[type];</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>事件触发</strong></p>
<p>事件触发是由<code>emit函数</code>来实现的，具体的含义就是发送一个事件，这个会同步的调用回调函数。 具体的源代码解析如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">type</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> er, handler, len, args, i, listeners;</div><div class="line">  <span class="comment">// 还是检查当前存储的events队列是否为空</span></div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._events)</div><div class="line">    <span class="keyword">this</span>._events = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="comment">// If there is no 'error' event listener then throw.</span></div><div class="line">  <span class="comment">// 这里需要对error进行特殊处理，如果没有error事件的监听者，直接会抛出error的错误，</span></div><div class="line">  <span class="comment">// 所有对error的时间的处理要特别注意。</span></div><div class="line">  <span class="comment">// 也就是所emit（‘error’）有抛出异常的功能，这个是文档中没有的</span></div><div class="line">  <span class="keyword">if</span> (type === <span class="string">'error'</span> &amp;&amp; !<span class="keyword">this</span>._events.error) &#123;</div><div class="line">    er = <span class="built_in">arguments</span>[<span class="number">1</span>];</div><div class="line">    <span class="comment">// 这个是具体domain的处理</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain) &#123;</div><div class="line">      <span class="keyword">if</span> (!er)</div><div class="line">        er = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Uncaught, unspecified "error" event.'</span>);</div><div class="line">      er.domainEmitter = <span class="keyword">this</span>;</div><div class="line">      er.domain = <span class="keyword">this</span>.domain;</div><div class="line">      er.domainThrown = <span class="literal">false</span>;</div><div class="line">      <span class="keyword">this</span>.domain.emit(<span class="string">'error'</span>, er);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (er <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</div><div class="line">      <span class="comment">// 直接抛出异常，如果emit一个参数Error的实例</span></div><div class="line">      <span class="keyword">throw</span> er; <span class="comment">// Unhandled 'error' event</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">//抛出生成的异常</span></div><div class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Uncaught, unspecified "error" event.'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 找到对应事件的回调函数</span></div><div class="line">  handler = <span class="keyword">this</span>._events[type];</div><div class="line"> <span class="comment">// 如果回调函数没有定义，说明不存在，直接返回false</span></div><div class="line">  <span class="keyword">if</span> (util.isUndefined(handler))</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  <span class="comment">// 如果是domain的使用，直接进入domain内处理</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.domain &amp;&amp; <span class="keyword">this</span> !== process)</div><div class="line">    <span class="keyword">this</span>.domain.enter();</div><div class="line">  <span class="comment">//处理是单个的函数的情况。</span></div><div class="line">  <span class="keyword">if</span> (util.isFunction(handler)) &#123;</div><div class="line">    <span class="comment">// 检查参数的情况，注意，至少有事件这一个argument。所以先处理1，2，3</span></div><div class="line">    <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</div><div class="line">      <span class="comment">// fast cases</span></div><div class="line">      <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        <span class="comment">// 当回调函数没有参数时候</span></div><div class="line">        handler.call(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">        <span class="comment">// 当回调函数有一个参数时候</span></div><div class="line">        handler.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">        <span class="comment">// 当回调函数有二个参数时候</span></div><div class="line">        handler.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>]);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="comment">// slower</span></div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="comment">// 当回调函数三个或者以上参数时候，就会做一个copy，然后再调用</span></div><div class="line">        <span class="comment">// 所以，这里我们可以特别注意的地方是，为了效率考虑，回调函数最好不要用3个或者3个以上的函数参数</span></div><div class="line">        len = <span class="built_in">arguments</span>.length;</div><div class="line">        args = <span class="keyword">new</span> <span class="built_in">Array</span>(len - <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</div><div class="line">          args[i - <span class="number">1</span>] = <span class="built_in">arguments</span>[i];</div><div class="line">        handler.apply(<span class="keyword">this</span>, args);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="comment">// 这里处理回调函数为一个数组的情况</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (util.isObject(handler)) &#123;</div><div class="line">    <span class="comment">// 这里直接生成一个参数的拷贝</span></div><div class="line">    len = <span class="built_in">arguments</span>.length;</div><div class="line">    args = <span class="keyword">new</span> <span class="built_in">Array</span>(len - <span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</div><div class="line">      args[i - <span class="number">1</span>] = <span class="built_in">arguments</span>[i];</div><div class="line">    <span class="comment">// 生成一个回调函数的新队列</span></div><div class="line">    listeners = handler.slice();</div><div class="line">    len = listeners.length;</div><div class="line">    <span class="comment">// 逐个调用回调函数</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">      listeners[i].apply(<span class="keyword">this</span>, args);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 处理domain 的情况，直接退出</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.domain &amp;&amp; <span class="keyword">this</span> !== process)</div><div class="line">    <span class="keyword">this</span>.domain.exit();</div><div class="line">  <span class="comment">//返回true，有回调函数处理的情况 </span></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/nodejs/node/blob/master/lib/events.js" target="_blank" rel="external">events源码</a></p>
<p><a href="http://blog.csdn.net/leoleocs/article/details/50162065" target="_blank" rel="external">Nodejs源码解析之events</a></p>
<p><a href="javascript设计模式与开发实践">发布-订阅模式</a></p>
</div>

    <div class="post-sidebar">
  <div class="toggle-btn" id="toggle-btn">
    <i class="fa fa-reorder"></i>
  </div>
  <section class="post-toc-wrap" id="post-sidebar">
    <h2 class="toc-title">内容目录</h2>
    <div class="post-toc">
      
      
        <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#发布—订阅模式"><span class="nav-text">发布—订阅模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码解析"><span class="nav-text">源码解析</span></a></li></ol></div>
      
    </div>
  </section>
</div>


  </div>

  <footer class="post-footer">
    
      <div class="post-tags">
        
          <a href="/tags#Node" rel="tag">#Node</a>
        
      </div>
    
    

  </footer>

</article>




      
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/11/20/Nodejs源码解析之events/"
           data-title="Nodejs源码解析之events" data-url="http://yoursite.com/2016/11/20/Nodejs源码解析之events/">
      </div>
    
  </div>




    </main>

    <footer class="footer clearfix">
  <div class="copyright" >
    <span>Copyright</span>
    
    &copy; 
    <span itemprop="copyrightYear">2017</span>
    <span class="author" itemprop="copyrightHolder">ChenXing</span>
  </div>

  <div class="info">
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <span id="busuanzi_container_site_pv">
        总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
  </div>

</footer>


  </div>

  <div class="back-top-btn" id="back-top-btn"><i class="fa fa-chevron-up"></i></div>





  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"xxxxxxxxxx"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     






<script type="text/javascript" src="/js/motto.min.js?v=0.4.5.1"></script>
<script type="text/javascript" src="/js/main.js?v=0.4.5.1"></script>


</body>
</html>
