
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>(转载)何为 connect 中间件 | ChenXing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="何为 connect 中间件
《何为 connect 中间件》目标
理解中间件的概念
了解 Connect 的实现

课程内容
原生 httpServer 遇到的问题
中间件思想
Connect 实现
Express 简介

这是从 httpServer 到 Express 的升级过程。
HTTPNodejs 的经典 httpServer 代码
1234567var http = require(">
<meta property="og:type" content="article">
<meta property="og:title" content="(转载)何为 connect 中间件">
<meta property="og:url" content="http://yoursite.com/2016/12/15/(转载)何为 connect 中间件/index.html">
<meta property="og:site_name" content="ChenXing">
<meta property="og:description" content="何为 connect 中间件
《何为 connect 中间件》目标
理解中间件的概念
了解 Connect 的实现

课程内容
原生 httpServer 遇到的问题
中间件思想
Connect 实现
Express 简介

这是从 httpServer 到 Express 的升级过程。
HTTPNodejs 的经典 httpServer 代码
1234567var http = require(">
<meta property="og:updated_time" content="2017-04-18T06:42:03.885Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="(转载)何为 connect 中间件">
<meta name="twitter:description" content="何为 connect 中间件
《何为 connect 中间件》目标
理解中间件的概念
了解 Connect 的实现

课程内容
原生 httpServer 遇到的问题
中间件思想
Connect 实现
Express 简介

这是从 httpServer 到 Express 的升级过程。
HTTPNodejs 的经典 httpServer 代码
1234567var http = require(">
  
    <link rel="alternative" href="/atom.xml" title="ChenXing" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ChenXing</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main"><article id="post-(转载)何为 connect 中间件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/15/(转载)何为 connect 中间件/" class="article-date">
  <time datetime="2016-12-15T02:53:53.000Z" itemprop="datePublished">2016-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Node/">Node</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      (转载)何为 connect 中间件
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/alsotang/node-lessons/blob/master/lesson18/README.md" target="_blank" rel="external">何为 connect 中间件</a></p>
<h1 id="《何为-connect-中间件》"><a href="#《何为-connect-中间件》" class="headerlink" title="《何为 connect 中间件》"></a>《何为 connect 中间件》</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>理解中间件的概念</li>
<li>了解 Connect 的实现</li>
</ol>
<h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ol>
<li>原生 httpServer 遇到的问题</li>
<li>中间件思想</li>
<li>Connect 实现</li>
<li>Express 简介</li>
</ol>
<p>这是从 httpServer 到 Express 的升级过程。</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>Nodejs 的经典 httpServer 代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(requestHandler);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.end(<span class="string">'hello visitor!'</span>);</div><div class="line">&#125;</div><div class="line">server.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>里面的函数 <code>requestHandler</code> 就是所有http请求的响应函数，即所有的请求都经过这个函数的处理，是所有请求的入口函数。</p>
<p>通过 requestHandler 函数我们能写一些简单的 http 逻辑，比如上面的例子，所有请求都返回 <code>hello visitor!</code>。</p>
<p>然而，我们的业务逻辑不可能这么简单。例如：需要实现一个接口，要做的是当请求过来时，先判断来源的请求是否包含请求体，然后判断请求体中的id是不是在数据库中存在，最后若存在则返回true，不存在则返回false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 检测请求中请求体是否存在，若存在则解析请求体；</div><div class="line"><span class="number">1.</span> 查看请求体中的id是否存在，若存在则去数据库查询；</div><div class="line"><span class="number">1.</span> 根据数据库结果返回约定的值；</div></pre></td></tr></table></figure>
<p>我们首先想到的，抽离函数，每个逻辑一个函数，简单好实现低耦合好维护。</p>
<p>实现代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseBody</span>(<span class="params">req, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">//根据http协议从req中解析body</span></div><div class="line">  callback(<span class="literal">null</span>, body);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIdInDatabase</span>(<span class="params">body, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">//根据body.id在Database中检测，返回结果</span></div><div class="line">  callback(<span class="literal">null</span>, dbResult);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnResult</span>(<span class="params">dbResult, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (dbResult &amp;&amp; dbResult.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    res.end(<span class="string">'true'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    res.end(<span class="string">'false'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  parseBody(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, body</span>) </span>&#123;</div><div class="line">    checkIdInDatabase(body, <span class="function"><span class="keyword">function</span>(<span class="params">err, dbResult</span>) </span>&#123;</div><div class="line">      returnResult(dbResult, res);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的解决方案解决了包含三个步骤的业务问题，出现了3个 <code>});</code> 还有3个 <code>err</code> 需要处理，上面的写法可以得达到预期效果。</p>
<p>然而，业务逻辑越来越复杂，会出发展成30个回调逻辑，那么就出现了30个 <code>});</code> 及30个 <code>err</code>异常。更严重的是，到时候写代码根本看不清自己写的逻辑在30层中的哪一层，极其容易出现 <strong>多次返回</strong> 或返回地方不对等问题，这就是 <strong>回调金字塔</strong> 问题了。</p>
<p>大多数同学应该能想到解决回调金字塔的办法，朴灵的《深入浅出Node.js》里讲到的三种方法。下面列举了这三种方法加上ES6新增的Generator，共四种解决办法。</p>
<ul>
<li><a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="external">EventProxy</a> —— 事件发布订阅模式(第四课讲到)</li>
<li><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">BlueBird</a> —— Promise方案(第十七课讲到)</li>
<li><a href="https://github.com/caolan/async" target="_blank" rel="external">Async</a> —— 异步流程控制库(第五课讲到)</li>
<li><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">Generator</a> —— ES6原生Generator</li>
</ul>
<p>理论上，这四种都能解决回调金字塔问题。而Connect和Express用的是 <code>类似异步流程控制的思想</code> 。</p>
<p>关于异步流程控制库下面简要介绍下，或移步<a href="https://github.com/alsotang/node-lessons/tree/master/lesson5" target="_blank" rel="external">@第五课</a>。 异步流程控制库首先要求用户传入待执行的函数列表，记为funlist。流程控制库的任务是让这些函数 <strong>顺序执行</strong> 。</p>
<p>callback是控制顺序执行的关键，funlist里的函数每当调用callback会执行下一个funlist里的函数</p>
<p>我们动手实现一个类似的链式调用，其中 <code>funlist</code> 更名为 <code>middlewares</code>、<code>callback</code> 更名为 <code>next</code>，码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> middlewares = [</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    parseBody(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, body</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</div><div class="line">      req.body = body;</div><div class="line">      next();</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    checkIdInDatabase(req.body.id, <span class="function"><span class="keyword">function</span>(<span class="params">err, rows</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);</div><div class="line">      res.dbResult = rows;</div><div class="line">      next();</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (res.dbResult &amp;&amp; res.dbResult.length &gt; <span class="number">0</span>) &#123;</div><div class="line">      res.end(<span class="string">'true'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      res.end(<span class="string">'false'</span>);</div><div class="line">    &#125;</div><div class="line">    next();</div><div class="line">  &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> i=<span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">//由middlewares链式调用</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">      <span class="keyword">return</span> res.end(<span class="string">'error:'</span>, err.toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (i&lt;middlewares.length) &#123;</div><div class="line">      middlewares[i++](req, res, next);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> ;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//触发第一个middleware</span></div><div class="line">  next();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面用middlewares+next完成了业务逻辑的 <code>链式调用</code>，而middlewares里的每个函数，都是一个 <code>中间件</code>。</p>
<p>整体思路是：</p>
<ol>
<li>将所有 <code>处理逻辑函数(中间件)</code> 存储在一个list中；</li>
<li>请求到达时 <code>循环调用</code> list中的 <code>处理逻辑函数(中间件)</code>；</li>
</ol>
<h1 id="Connect的实现"><a href="#Connect的实现" class="headerlink" title="Connect的实现"></a><a href="https://github.com/senchalabs/connect" target="_blank" rel="external">Connect</a>的实现</h1><p>Connect的思想跟上面阐述的思想基本一样，先将处理逻辑存起来，然后循环调用。</p>
<p>Connect中主要有五个函数 PS: Connect的核心代码是200+行，建议对照<a href="https://github.com/senchalabs/connect/blob/master/index.js" target="_blank" rel="external">源码</a>看下面的函数介绍。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>createServer</td>
<td>包装httpServer形成app</td>
</tr>
<tr>
<td>listen</td>
<td>监听端口函数</td>
</tr>
<tr>
<td>use</td>
<td>向middlewares里面放入业务逻辑</td>
</tr>
<tr>
<td>handle</td>
<td>上一章的requestHandler函数增强版</td>
</tr>
<tr>
<td>call</td>
<td>业务逻辑的真正执行者</td>
</tr>
</tbody>
</table>
<h2 id="createServer"><a href="#createServer" class="headerlink" title="createServer()"></a>createServer()</h2><p><strong>输入</strong>:</p>
<p>无</p>
<p><strong>执行过程</strong>:</p>
<ol>
<li>app是一个函数对象(包含handle方法)</li>
<li>app具有Event所有属性(详见<a href="https://github.com/jaredhanson/utils-merge" target="_blank" rel="external">utils-merge</a>，十行代码)</li>
<li>app有route属性(路由)、和stack属性(用于存储中间件，类似上面的<a href="https://github.com/alsotang/node-lessons/blob/master/lesson18/README.md#middlewares" target="_blank" rel="external">middlewares</a>)</li>
</ol>
<p><strong>输出</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     app is <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;...&#125;;</div><div class="line">      |</div><div class="line">  +---+---+</div><div class="line">  |  has  |</div><div class="line">route   stack</div></pre></td></tr></table></figure>
<h2 id="app-use-route-fn"><a href="#app-use-route-fn" class="headerlink" title="app.use(route, fn)"></a>app.use(route, fn)</h2><p>作用是向stack中添加 <code>逻辑处理函数</code> (中间件)。</p>
<p><strong>输入</strong>:</p>
<ol>
<li>route 可省略，默认’/‘</li>
<li>fn 具体的业务处理逻辑</li>
</ol>
<p><strong>tips:</strong></p>
<p>上面的fn表示处理逻辑，它可以是</p>
<ol>
<li>一个普通的 <code>function(req,res[,next]){}</code>；</li>
<li>一个<a href="https://lodejs.org/api/http.html#http_class_http_server" target="_blank" rel="external">httpServer</a>；</li>
<li>另一个connect的app对象(<strong>sub app特性</strong>)；</li>
</ol>
<p>由于它们的本质都是 <code>处理逻辑</code>，都可以用一个 <code>function(req,res,next){}</code>将它们概括起来，Connect把他们都转化为这个函数，然后把它们存起来。</p>
<p>如何将这三种分别转换为 function(req, res, next) {}的形式呢？</p>
<ol>
<li>不用转换；</li>
<li>httpServer的定义是“对事件’request’后handler的对象”，我们可以从httpServer.listeners(‘request’)中得到这个函数；</li>
<li>另一个connect对象，而connect()返回的app就是function(req, res, out) {}；</li>
</ol>
<p><strong>执行过程</strong>:</p>
<ol>
<li>将三种<code>处理逻辑</code>统一转换为<code>function(req,res,next){}</code>的形式表示。</li>
<li>把这个<code>处理逻辑</code>与route一起，放入<code>stack</code>中(存储处理逻辑，route用来匹配路由)</li>
</ol>
<p>核心代码片段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//route是路由路径，handle是一个`function(req, res, next) &#123;...&#125;`形式的业务逻辑</span></div><div class="line"><span class="keyword">this</span>.stack.push(&#123; <span class="attr">route</span>: path, <span class="attr">handle</span>: handle &#125;);</div></pre></td></tr></table></figure>
<p><strong>返回</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回自己，可以完成链式调用</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</div></pre></td></tr></table></figure>
<p><strong>总结:</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = connect();</div><div class="line">app.use(<span class="string">'/api'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = connect();</div><div class="line">app.stack.push(&#123;<span class="attr">route</span>: <span class="string">'/api'</span>, <span class="attr">handle</span>: <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;&#125;&#125;);</div></pre></td></tr></table></figure>
<p>最后，app.stack里 <strong>顺序存储</strong> 了所有的 <strong>逻辑处理函数</strong> (中间件)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.stack = [function1, function2, function3, ... function30];</div></pre></td></tr></table></figure>
<h2 id="app-handle-req-res-out"><a href="#app-handle-req-res-out" class="headerlink" title="app.handle(req, res, out)"></a>app.handle(req, res, out)</h2><p>这个函数就是请求到达时，负责 <code>顺序调用</code> 我们存储在stack中的 <code>逻辑处理函数</code> (中间件)函数，类似上一章的requestHandler。</p>
<p><strong>输入:</strong></p>
<ol>
<li>req是Nodejs本身的可读流，不做过多介绍</li>
<li>res是Nodejs本身的可写流，不做过多介绍</li>
<li>out是为了Connect的 <strong>sub app特性</strong> 而设计的参数，这个特性可以暂时忽略，这个参数我们暂时不关心</li>
</ol>
<p><strong>处理过程:</strong></p>
<p>可以回头看一下上面的<a href="https://github.com/alsotang/node-lessons/blob/master/lesson18/README.md#middlewares" target="_blank" rel="external">requestHandler函数</a>，handle的实现是这个函数的增强版</p>
<ol>
<li>取得stack(存储<code>逻辑处理函数</code>列表)，index(列表下标)</li>
<li>构建next函数，next的作用是执行下一个<code>逻辑处理函数</code></li>
<li>触发第一个next，触发链式调用</li>
</ol>
<p><strong>next函数实现:</strong></p>
<p>next函数实现在handle函数体内，用来<code>顺序执行处理逻辑</code>，它是异步流程控制库的核心，不明白它的作用请看<a href="https://github.com/alsotang/node-lessons/blob/master/lesson18/README.md#next" target="_blank" rel="external">上面的异步流程控制库简介</a></p>
<p>path是请求路径，route是<code>逻辑处理函数</code>自带的属性。</p>
<ol>
<li>取得下一个<code>逻辑处理函数</code>;</li>
<li>若路由不匹配，跳过此逻辑;</li>
<li>若路由匹配<a href="https://github.com/alsotang/node-lessons/blob/master/lesson18/README.md#call" target="_blank" rel="external">下面的call</a>执行匹配到的<code>逻辑处理函数</code></li>
</ol>
<p>tips: 跟上一章最后的代码一样，每个<code>逻辑处理函数</code>调用<code>next</code>来让后面的函数执行，存储在stack中的函数就实现了<code>链式调用</code>。不一定所有的函数都在返回的时候才调用<code>next</code>，为了不影响效率，有的函数可能先调用next，然而自己还没有返回，继续做自己的事情。</p>
<p>核心代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取下一个逻辑逻辑处理函数</span></div><div class="line"><span class="number">1</span>:  <span class="keyword">var</span> layer = stack[index++];</div><div class="line"><span class="comment">//不匹配时跳过</span></div><div class="line"><span class="number">2</span>:  <span class="keyword">if</span> (path.toLowerCase().substr(<span class="number">0</span>, route.length) !== route.toLowerCase()) &#123;</div><div class="line">      <span class="keyword">return</span> next(err);</div><div class="line">    &#125;</div><div class="line"><span class="comment">//匹配时执行</span></div><div class="line"><span class="number">3</span>:  call(layer.handle, route, err, req, res, next);</div></pre></td></tr></table></figure>
<p><strong>返回:</strong></p>
<p>无</p>
<p><strong>总结:</strong></p>
<p>画图总结</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">request come</div><div class="line">     |</div><div class="line">     v</div><div class="line">middleware1 :  不匹配路由，skip</div><div class="line">     |</div><div class="line">     v</div><div class="line">middleware2 :  匹配路由，执行</div><div class="line">     |</div><div class="line">     v</div><div class="line">middleware3 :  匹配路由，执行</div><div class="line">     |</div><div class="line">     v</div><div class="line">middleware4 :  不匹配路由，skip</div><div class="line">     |</div><div class="line">     v</div><div class="line">    end</div></pre></td></tr></table></figure>
<h2 id="call-handle-route-err-req-res-next"><a href="#call-handle-route-err-req-res-next" class="headerlink" title="call(handle, route, err, req, res, next)"></a>call(handle, route, err, req, res, next)</h2><blockquote>
<p>这里有个比较有趣的知识，<code>console.log(Function.length)</code>会返回函数定义的参数个数。值跟在函数体内执行<code>arguments.length</code>一样。</p>
</blockquote>
<p>Connect中规定<code>function(err, req, res, next) {}</code>形式为错误处理函数，<code>function(req, res, next) {}</code>为正常的业务逻辑处理函数。那么，可以根据Function.length以判断它是否为错误处理函数。</p>
<p><strong>输入:</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>handle</td>
<td>逻辑处理函数</td>
</tr>
<tr>
<td>route</td>
<td>路由</td>
</tr>
<tr>
<td>err</td>
<td>是否发生过错误</td>
</tr>
<tr>
<td>req</td>
<td>Nodejs对象</td>
</tr>
<tr>
<td>res</td>
<td>Nodejs对象</td>
</tr>
<tr>
<td>next</td>
<td>next函数</td>
</tr>
</tbody>
</table>
<p><strong>处理过程:</strong></p>
<ol>
<li>是否有错误，本次handle是否是错误处理函数;</li>
<li>若有错误且handle为错误处理函数，则执行handle，本函数返回;</li>
<li>若没错误且handle不是错误处理函数，则执行handle，本函数返回;</li>
<li>如果上面两个都不满足，不执行handle，本函数调用next，返回;</li>
</ol>
<p><strong>返回:</strong></p>
<p>无</p>
<p><strong>总结:</strong></p>
<p>call函数是一个执行者，根据当前<code>错误情况</code>和<code>handle类型</code>决定<code>是否执行</code>当前的handle。</p>
<h2 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h2><p>创建一个httpServer，将Connect自己的业务逻辑作为requestHandler，监听端口</p>
<p>代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</div><div class="line"><span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</div></pre></td></tr></table></figure>
<h2 id="图解Connect"><a href="#图解Connect" class="headerlink" title="图解Connect"></a>图解Connect</h2><p>Connect将中间件存储在app.stack中，通过构造handle中的next函数在请求到来时依次调用这些中间件。</p>
<p>图形总结</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">request               app(out)</div><div class="line">   |                          yes</div><div class="line">   +------------------&gt;match?-----&gt;middleware1</div><div class="line">                         | no          |</div><div class="line">                         v             |</div><div class="line">                        next&lt;----------+</div><div class="line">                         |</div><div class="line">                         v    yes</div><div class="line">                      match?------&gt;middleware2</div><div class="line">                         | no          |</div><div class="line">                         v             |</div><div class="line">                        next&lt;----------+</div><div class="line">                         |</div><div class="line">                         v    yes</div><div class="line">                      match?------&gt;middleware3</div><div class="line">                         | no          |</div><div class="line">                         v             |</div><div class="line">                        out&lt;-----------+</div><div class="line">                         |</div><div class="line">   +---------------------+</div><div class="line">   |</div><div class="line">   v</div><div class="line">  end(response在处理过程中已经返回了)</div></pre></td></tr></table></figure>
<h2 id="Connect的subapp特性"><a href="#Connect的subapp特性" class="headerlink" title="Connect的subapp特性"></a>Connect的subapp特性</h2><p>我们再看看Connect是怎么实现subapp的，比较有趣。</p>
<p>什么是subapp?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sub_app = connect();</div><div class="line"><span class="keyword">var</span> app = connect();</div><div class="line"></div><div class="line">app.use(<span class="string">'/route1'</span>, sub_app);</div><div class="line"><span class="comment">// request path: '/route1/route2'</span></div><div class="line"><span class="comment">// 由app接收到请求后，切割 path为'/route2'转交给sub_app的处理逻辑处理</span></div><div class="line"><span class="comment">// 再由sub_app返回到app，由app继续向下执行处理逻辑</span></div></pre></td></tr></table></figure>
<p>结合上面的函数画图</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">request               app(out1)                 sub_app(out2)</div><div class="line">   |</div><div class="line">   +---------------&gt;middleware1     +------------&gt;middleware1</div><div class="line">                         |          |                 |</div><div class="line">                        next        |                next</div><div class="line">                         |          |                 |</div><div class="line">                         v          |                 v</div><div class="line">                    middleware2-----+            middleware2</div><div class="line">                                                      |</div><div class="line">                       next&lt;--------+                next</div><div class="line">                         |          |                 |</div><div class="line">                         v          |                 v</div><div class="line">                     middleware3    |            middleware3</div><div class="line">                         |          |                 |</div><div class="line">                         v          |                 v</div><div class="line">                        out1        |                out2</div><div class="line">                         |          |                 |</div><div class="line">   +---------------------+          +-----------------+</div><div class="line">   |</div><div class="line">   v</div><div class="line">  end(response在处理过程中已经返回了)</div></pre></td></tr></table></figure>
<p>完成上面的sub_app只需要做到两点：</p>
<ol>
<li>从app的调用链进入到sub_app的调用链中;</li>
<li>从sub_app的逻辑回到app的调用链中;</li>
</ol>
<p>connect在handle函数中的第三个参数<code>out</code>为这个特性实现提供可能。<code>out</code>的特点是<code>在middlewares链式调用完成以后调用</code>。<strong>那么将app的next作为sub_app的out传入sub_app的handle中</strong>可以做到sub_app自己的业务逻辑处理完后调用<code>out</code>，即处理权回到了本app的<code>next</code>手里。</p>
<p>上面图中的<code>sub_app.out2===app.next</code>，所以能完成逻辑的交接和sub app调用。</p>
<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a><a href="https://github.com/strongloop/express" target="_blank" rel="external">Express</a></h1><p>大家都知道Express是Connect的升级版。</p>
<p>Express不只是Connect的升级版，它还封装了很多对象来方便业务逻辑处理。Express里的Router是Connect的升级版。</p>
<p>Express大概可以分为几个模块</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>router</td>
<td>路由模块是Connect升级版</td>
</tr>
<tr>
<td>request</td>
<td>经过Express封装的req对象</td>
</tr>
<tr>
<td>response</td>
<td>经过Express封装的res对象</td>
</tr>
<tr>
<td>application</td>
<td>app上面的各种默认设置</td>
</tr>
</tbody>
</table>
<p>简要介绍一下每个模块</p>
<h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>在Connect中间件特性的基础上，加入了如下特性，是Connect的升级版</p>
<ol>
<li>正则匹配route;</li>
<li>进行将http的方法在route中分解开;</li>
</ol>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>在Request中集成了http.IncomingMessage(可读流+事件)，并在其上增加了新的属性，方便使用，我们最常用的应该是 req.param。</p>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>在Response中集成了http.ServerResponse(可写流+事件)，并在其上增加了很多方便返回的函数，有我们熟悉的res.json、 res.render、res.redirect、res.sendFile等等。</p>
<p>我们可以拓展它写一个res.sendPersonInfoById。</p>
<blockquote>
<p>关于流的题外话：req.pipe(res)的形式可以“完成发什么就返回什么”，而req.pipe(mylogic).pipe(res)可以添加自己的逻辑， 我们的业务逻辑是把流读为String/Object再进行逻辑处理，处理完再推送给另一个stream，有没有可能在流的层面进行逻辑解 耦提供服务呢？求大神解答了…至少这种写法在大流量、逻辑简单的情况下是有用的。</p>
</blockquote>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>除了上面的三个模块以外，还需要有个地方存储整个app的属性、设置等。比较常用的是app.engine函数设置模板引擎。</p>
<h2 id="Express小结"><a href="#Express小结" class="headerlink" title="Express小结"></a>Express小结</h2><p>Express是一个中间件机制的httpServer框架，它本身实现了中间件机制，它也包含了中间件。比如3.x版本的Express 本身自带bodyParser、cookieSession等中间件，而在4.x中去掉了。包括TJ也写了很多中间件，比如node-querystring、 connect-redis等。</p>
<p>实现业务逻辑解耦时，中间件是从纵向的方面进行的逻辑分解，前面的中间件处理的结果可以给后面用，比如bodyParser把解析 body的结果放在req.body中，后面的逻辑都可以从req.body中取值。由于中间件是顺序执行的，errHandler一般都放在最后，而log类的中间件则放在比较前面。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Connect用流程控制库的回调函数及中间件的思想来解耦回调逻辑； <a href="https://github.com/koajs/koa" target="_blank" rel="external">Koa</a>用Generator方法解决回调问题；</p>
<p>我们应该也可以用事件、Promise的方式实现；</p>
<p>PS: 用事件来实现的话还挺期待的，能形成网状的相互调用。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/12/15/(转载)何为 connect 中间件/" data-id="cj8lswfm8000b5svbwq7xeb14" class="article-share-link" data-share="baidu" data-title="(转载)何为 connect 中间件">Share</a>
      

      
        <a href="http://yoursite.com/2016/12/15/(转载)何为 connect 中间件/#ds-thread" class="article-comment-link">Comments</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node/">Node</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/12/20/(自备)异步流程控制模块Async/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (自备)异步流程控制模块Async
        
      </div>
    </a>
  
  
    <a href="/2016/11/25/es6学习之Class/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">es6 学习之 Class</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2016/12/15/(转载)何为 connect 中间件/" data-title="(转载)何为 connect 中间件" data-url="http://yoursite.com/2016/12/15/(转载)何为 connect 中间件/"></div>
  </section>
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node/">Node</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/es6/">es6</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/">Node</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 17.5px;">JavaScript</a> <a href="/tags/Node/" style="font-size: 20px;">Node</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/es6/" style="font-size: 12.5px;">es6</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/tools/" style="font-size: 12.5px;">tools</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/15/koa-router小笔记/">koa-router小笔记</a>
          </li>
        
          <li>
            <a href="/2017/09/10/一些源码分析解析/">一些npm包源码分析</a>
          </li>
        
          <li>
            <a href="/2017/09/02/fiddler/">fiddler抓包工具</a>
          </li>
        
          <li>
            <a href="/2017/05/02/这些年我用过的软件/">那些年我用过的软件</a>
          </li>
        
          <li>
            <a href="/2017/04/02/利用pipe处理并发/">利用pipe处理并发的可行性</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Links</h3>
    <div class="widget">
      <ul>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 ChenXing<br>
      Powered by <a href="//hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="totop"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"reqianduan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<div id="article-share-box" class="article-share-box">
  <div id="bdshare" class="bdsharebuttonbox article-share-links">
    <a class="article-share-weibo" data-cmd="tsina" title="分享到新浪微博"></a>
    <a class="article-share-weixin" data-cmd="weixin" title="分享到微信"></a>
    <a class="article-share-qq" data-cmd="sqq" title="分享到QQ"></a>
    <a class="article-share-renren" data-cmd="renren" title="分享到人人网"></a>
    <a class="article-share-more" data-cmd="more" title="更多"></a>
  </div>
</div>
<script>
  function SetShareData(cmd, config) {
    if (shareDataTitle && shareDataUrl) {
      config.bdText = shareDataTitle;
      config.bdUrl = shareDataUrl;
    }
    return config;
  }
  window._bd_share_config={
    "common":{onBeforeClick: SetShareData},
    "share":{"bdCustomStyle":"/css/bdshare.css"}
  };
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js"></script>

</div>
</body>
</html>
